{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"kapipy","text":"<p>A python client for accessing and querying datasets from geospatial open data portals such as LINZ, Stats NZ and LRIS.</p>"},{"location":"#overview","title":"Overview","text":"<p>kapipy is a Python package that provides a python interface to the Koordinates geospatial content management system. It allows users to connect a data portal, retrieve metadata, and query vector layers and tables. </p>"},{"location":"#disclaimer","title":"Disclaimer","text":"<p>This is a hobby project and the modules are provided as-is on a best-effort basis and you assume all risk for using it. The author has no affiliation with either Koordinates nor LINZ, Stats NZ or LRIS. As such, the underlying API's and services may change at any time without warning and break these modules.  </p> <p>This project does not cover the full spectrum of the Koordinates API and probably never will. It focuses currently on basic workflows such as connecting using an api key, getting references to datasets and downloading them.  </p> <p>Suggestions and code contributions can be made by submitting issues via the GitHub page.    </p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install kapipy\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<ul> <li>Import kapipy.  </li> <li>Create a GIS object, passing in an api key.  </li> <li>Get a reference to an item using {gis}.content.get({layer_id})</li> <li>Perform actions on the item.  </li> </ul> <p>Basic example:  </p> <pre><code>from kapipy.gis import GIS\nlinz = GIS(name=\"linz\", api_key=\"my-linz-api-key\")\nrail_station_layer_id = \"50318\"\nitm = linz.content.get(rail_station_layer_id)\ndata = itm.query()\ndata.head()\n</code></pre>"},{"location":"development_notes/","title":"Development Notes","text":"<p>These are just general notes for the author to help remember design choices, rabbit holes and how they panned out, etc.  </p>"},{"location":"development_notes/#installation","title":"Installation","text":"<p>When I run <code>uv sync</code> and <code>uv pip install -e .</code> on a new cloned copy, if I have a python environment activated already in my terminal it seems to do odd things sometimes. VS Code sometimes activates automatically depending on settings. And sometimes those settings vary between PowerShell and the standard Command Prompt. So I find it best to ensure I open a separate Command Prompt window with nothing activated, run those initial commands there, and then open up VS Code and any terminal windows. </p> <p>If installing from the whl file using UV, remember to add the package name.</p> <pre><code>uv pip install kapipy@path/to/packagefile.whl\n</code></pre> <p>If using the code directly rather than installing from PyPi (once it is uploaded to there), run the following to install the package locally in editable mode.</p> <pre><code>pip install -e .\n</code></pre>"},{"location":"development_notes/#arcgis","title":"ArcGIS","text":"<p>Recommend using the existing conda manager that comes installed with ArcGIS Pro or ArcGIS Server. If using arcgis module but not arcpy installed, need to install: - pyproj - shapely - pyshp</p> <p>Optionally pip install dotenv if wanting to use that. If creating a blank conda environment (rather than cloning the default), and wanting to use Jupyter notebooks, install: - ipykernel - ptyprocess - comm</p> <p>When converting geojson to sdf, I first tried using FeatureSet.from_geojson(geojson) but I found that it assumes that the geojson is in wgs84 (which is the strict definition of geojson). But in our case sometimes we often get the geojson returned already in NZTM/2193. So the from_geojson ended up with incorrect spatial data.  So I write a function that manually converts the geojson to an ArcGIS FeatureSet by passing in the json, fields and wkid. Then I can convert that FeatureSet to an sdf.  </p>"},{"location":"development_notes/#development-using-jupyter-notebooks","title":"Development using Jupyter Notebooks","text":"<p>I got the following tips from Cookie Cutter Data Science. Cookie Cutter Data Science </p> <p>Make the project a python package and install it locally. I was using UV, so I ran this command:</p> <pre><code>uv pip install -e .  \n</code></pre> <p>Then, in my notebook, I included this cell first:  </p> <pre><code>%load_ext autoreload\n%autoreload 2\n</code></pre> <p>This allowed me to load my local python package like this:  </p> <pre><code>from k_data_helpers import KServer  \n</code></pre> <p>And it would hot reload any changes I made while developing.</p>"},{"location":"development_notes/#koordinates-api","title":"Koordinates API","text":""},{"location":"development_notes/#export-api","title":"Export API","text":"<p>The export api doesn't appear to have an option for applying a cql_filter or any similar filter. Only extent. The extent appears to have to be a geojson geometry object. Note that this is just the geometry part, not the properties or collection. And it would have to be in WGS84. I might look at ways to handle passing in geometry objects of different types, such as from a geopandas geometry, and behind the scenes just handling that and converting to the corrrect format.  </p> <p>Also, the export API treats the extent as a crop, and so features will be clipped. This may not be desired in all situations, e.g. clipping Property Parcels is not usually a good thing as someone may inadvertantly think that that is the actually parcel geometry, not realising it was clipped. The question is: how to handle this? Just warn the user in documentation and leave it up to them? Apply a buffer and do some post-processing? I'm inclined to do less, let the system supply as it is designed, and educate the user. This does imply the end user needs to do a little bit extra work but I would rather the user explicitly get the output and the module logic not get in the way.  </p> <p>It does appear to allow generating an export of multiple items at once. E.g. you could request several layers in one zipped file geodatabase. Currently, this wrapper only supports one at a time, because I didn't realise at the time you could do multiple, so this would be a good enhancement for the future. The current approach is based off starting with an item and downloading that. So a multi item download would need to be initiated by a higher order class, perhaps the ContentManager?  </p> <p>Need to think about how a user would most likely pass in the parameters for a multi download without constructing the whole list verbosely, but allowing them to do that if they wish.  </p>"},{"location":"development_notes/#notes-on-design-choices","title":"Notes on design choices","text":""},{"location":"development_notes/#owslib","title":"OWSLib","text":"<p>I investigated using the OWSLib python package to download the WFS data, but discovered that it doesn't support the CQL filter keyword option that the LINZ GeoServer provides. OGC filters were still an option, but seem very complex to construct and I believe most users would prefer to use the simpler CQL which is more similar to SQL. So I moved back to using a basic request to the WFS endpoint. The OWSLib package would provide more scope for expansion, but since the intent of this helper library is primarily focused on Koordinates and LINZ in particular, we can afford to be a little more opinionated on our approach, such as not having to support all the WFS versions. I'm not sure if the LINZ WFS endpoint is strictly equivalent with all other Koordinates WFS endpoints. So the implementation at the moment is coded to work with LINZ and might not work in other places.  </p>"},{"location":"development_notes/#prompts","title":"Prompts","text":"<p>Can you review the docstrings for all classes, methods and functions. Make sure they are accurate and reflect the correct Parameters and Return values. Ensure the syntax is correct, use the word Parameters instead of Args, and ensure the formatting is consistent for use with MkDocs and the Google format. Only provide docstrings that actually need to change. Provide each docstring in a separate section so I can copy and paste it. There is no need to provide the original for comparison. Provide an update for str and repr if necessary. Check that the type hints are accurate.</p>"},{"location":"development_notes/#tests","title":"Tests","text":"<p>Tests are written using pytest.</p> <p>To run all tests with logging. Leave off the log parameter if not wanting logging.  </p> <pre><code>uv run -m pytest --log-cli-level=INFO\n</code></pre> <p>To run a specific test, replace the relevant file name and test function.  </p> <pre><code>uv run -m pytest tests/test_simple.py::test_validate_layer_export_params --log-cli-level=INFO\n</code></pre> <p>There is currently very limited test coverage. Any live tests require a \"LINZ_API_KEY\" entry to exist in a .env file in the root project folder.  </p>"},{"location":"reference/","title":"API Reference","text":"<p>Client for connecting to a Koordinates server.</p> <p>Provides methods for authenticating, accessing content, and making HTTP requests to the Koordinates API. Used as the main entry point for interacting with Koordinates-hosted data.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the Koordinates portal.</p> <code>url</code> <code>str</code> <p>The base URL of the Koordinates server.</p> <code>_api_version</code> <code>str</code> <p>The API version to use.</p> <code>_content_manager</code> <code>ContentManager or None</code> <p>Cached ContentManager instance.</p> <code>_wfs_manager</code> <code>object or None</code> <p>Cached WFS manager instance (if implemented).</p> <code>_api_key</code> <code>str</code> <p>The API key for authenticating requests.</p> Source code in <code>src\\kapipy\\gis\\__init__.py</code> <pre><code>class GIS:\n    \"\"\"\n    Client for connecting to a Koordinates server.\n\n    Provides methods for authenticating, accessing content, and making HTTP requests to the Koordinates API.\n    Used as the main entry point for interacting with Koordinates-hosted data.\n\n    Attributes:\n        name (str): The name of the Koordinates portal.\n        url (str): The base URL of the Koordinates server.\n        _api_version (str): The API version to use.\n        _content_manager (ContentManager or None): Cached ContentManager instance.\n        _wfs_manager (object or None): Cached WFS manager instance (if implemented).\n        _api_key (str): The API key for authenticating requests.\n    \"\"\"\n\n    def __init__(\n        self,\n        name=None,\n        url=None,\n        api_key=None,\n        api_version=DEFAULT_API_VERSION,\n    ) -&gt; None:\n        \"\"\"\n        Initializes the GIS instance with the base URL, API version, and API key.\n\n        Parameters:\n            name (str, optional): The name of the Koordinates portal (e.g., 'linz'). If provided, overrides url.\n            url (str, optional): The base URL of the Koordinates server. Used if name is not provided.\n            api_key (str): The API key for authenticating with the Koordinates server.\n            api_version (str, optional): The API version to use. Defaults to 'v1.x'.\n\n        Raises:\n            ValueError: If the portal name is not recognized or if api_key is not provided.\n        \"\"\"\n\n        if name and PORTAL_DETAILS.get(name.lower(), None) is None:\n            raise ValueError(\"Supplied portal name is not included in default list.\")\n        if name:\n            self.name = PORTAL_DETAILS.get(name.lower()).get(\"name\")\n            self.url = PORTAL_DETAILS.get(name.lower()).get(\"url\")\n        self.url = (\n            self.url if self.url.endswith(\"/\") else f\"{self.url}/\"\n        )  # ensure trailing slash\n        self._api_version = api_version\n        self._content_manager = None\n        self._wfs_manager = None\n        self._api_key = api_key\n        if not self._api_key:\n            raise ValueError(\"API key must be provided.\")\n        logger.debug(f\"GIS initialized with URL: {self.url}\")\n\n    @property\n    def _service_url(self) -&gt; str:\n        \"\"\"\n        Returns the service URL for the Koordinates server.\n\n        Returns:\n            str: The full service URL, ending with a slash.\n        \"\"\"\n        url = f\"{self.url}{SERVICES_PATH}\"\n        return url if url.endswith(\"/\") else f\"{url}/\"\n\n    @property\n    def _api_url(self) -&gt; str:\n        \"\"\"\n        Returns the API URL for the Koordinates server.\n\n        Returns:\n            str: The full API URL, ending with a slash.\n        \"\"\"\n        url = f\"{self._service_url}{API_PATH}{self._api_version}/\"\n        return url if url.endswith(\"/\") else f\"{url}/\"\n\n    @property\n    def _wfs_url(self) -&gt; str:\n        \"\"\"\n        Returns the WFS URL for the Koordinates server.\n\n        Returns:\n            str: The full WFS URL, ending with a slash.\n        \"\"\"\n\n        url = f\"{self._service_url}{WFS_PATH}\"\n        return url if url.endswith(\"/\") else f\"{url}/\"\n\n    @property\n    def content(self) -&gt; \"ContentManager\":\n        \"\"\"\n        Returns the ContentManager instance for this server.\n\n        Returns:\n            ContentManager: The content manager associated with this server.\n        \"\"\"\n\n        if self._content_manager is None:\n            from . import ContentManager\n\n            self._content_manager = ContentManager(self)\n        return self._content_manager\n\n    def get(self, url: str, params: dict = None) -&gt; dict:\n        \"\"\"\n        Makes a synchronous GET request to the specified URL with the provided parameters.\n        Injects the API key into the request headers.\n\n        Parameters:\n            url (str): The URL to send the GET request to.\n            params (dict, optional): Query parameters to include in the request. Defaults to None.\n\n        Returns:\n            dict: The JSON-decoded response from the server.\n\n        Raises:\n            BadRequest: If the request fails with a 400 status code.\n            ServerError: For other HTTP errors or request exceptions.\n        \"\"\"\n\n        headers = {\"Authorization\": f\"key {self._api_key}\"}\n        logger.debug(f\"Making kserver GET request to {url} with params {params}\")\n        try:\n            response = httpx.get(url, headers=headers, params=params, timeout=30)\n        except httpx.RequestError as exc:\n            logger.error(f\"An error occurred while requesting {exc.request.url!r}.\")\n            raise ServerError(str(exc)) from exc\n\n        if response.status_code == 400:\n            raise BadRequest(response.text)\n        response.raise_for_status()\n        return response.json()\n\n    def reset(self) -&gt; None:\n        \"\"\"\n        Resets the GIS instance, forcing the content manager and WFS manager\n        to reinitialize the next time they are accessed. This is useful if the API key\n        or other configurations change.\n\n        Returns:\n            None\n        \"\"\"\n\n        self._content_manager = None\n        self._wfs_manager = None\n        logger.info(\"KServer instance reset.\")\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Returns an unambiguous string representation of the GIS instance.\n\n        Returns:\n            str: String representation of the GIS instance.\n        \"\"\"\n        return (\n            f\"GIS(name={self.name!r}, url={self.url!r}, api_key={'***' if self._api_key else None}, \"\n            f\"api_version={self._api_version!r})\"\n        )\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Returns a user-friendly string representation of the GIS instance.\n\n        Returns:\n            str: User-friendly string representation.\n        \"\"\"\n        return f\"GIS: {self.name or 'Custom'} at {self.url} (API {self._api_version})\"\n</code></pre> <p>Base class for representing an item in the Koordinates system.</p> <p>This class provides a structure for items that can be extended by specific item types. It stores basic metadata and provides dynamic attribute access.</p> <p>Attributes:</p> Name Type Description <code>_gis</code> <code>GIS</code> <p>The GIS instance this item belongs to.</p> <code>_raw_json</code> <code>dict</code> <p>The raw JSON dictionary representing the item.</p> <code>id</code> <code>str</code> <p>The unique identifier of the item.</p> <code>url</code> <code>str</code> <p>The URL of the item.</p> <code>type</code> <code>str</code> <p>The type of the item (e.g., 'layer', 'table').</p> <code>kind</code> <code>str</code> <p>The kind of the item (e.g., 'vector', 'table').</p> <code>title</code> <code>str</code> <p>The title of the item.</p> <code>description</code> <code>str</code> <p>The description of the item.</p> <code>_jobs</code> <code>list</code> <p>List of JobResult objects associated with this item.</p> Source code in <code>src\\kapipy\\gis\\base_item.py</code> <pre><code>class BaseItem:\n    \"\"\"\n    Base class for representing an item in the Koordinates system.\n\n    This class provides a structure for items that can be extended by specific item types.\n    It stores basic metadata and provides dynamic attribute access.\n\n    Attributes:\n        _gis (GIS): The GIS instance this item belongs to.\n        _raw_json (dict): The raw JSON dictionary representing the item.\n        id (str): The unique identifier of the item.\n        url (str): The URL of the item.\n        type (str): The type of the item (e.g., 'layer', 'table').\n        kind (str): The kind of the item (e.g., 'vector', 'table').\n        title (str): The title of the item.\n        description (str): The description of the item.\n        _jobs (list): List of JobResult objects associated with this item.\n    \"\"\"\n\n    def __init__(self, gis: \"GIS\", item_dict: dict) -&gt; None:\n        \"\"\"\n        Initializes the BaseItem instance from a dictionary returned from the API.\n\n        Parameters:\n            gis (GIS): The GIS instance that this item belongs to.\n            item_dict (dict): A dictionary containing the item's details, typically from an API response.\n\n        Returns:\n            None\n        \"\"\"\n\n        self._gis = gis\n        self._raw_json = item_dict\n        self.id = item_dict.get(\"id\")\n        self.url = item_dict.get(\"url\")\n        self.type = item_dict.get(\"type\")\n        self.kind = item_dict.get(\"kind\")\n        self.title = item_dict.get(\"title\")\n        self.description = item_dict.get(\"description\")\n        self._jobs = []\n\n    def __getattr__(self, item) -&gt; object:\n        \"\"\"\n        Provides dynamic attribute access for the item.\n\n        Parameters:\n            item (str): The name of the attribute to access.\n\n        Returns:\n            object: The value of the requested attribute.\n\n        Raises:\n            AttributeError: If the attribute does not exist in the item.\n        \"\"\"\n\n        attr = self._raw_json.get(item, None)\n        if attr is None:\n            raise AttributeError(f\"{self.__class__.__name__} has no attribute '{item}'\")\n        return attr\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Returns an unambiguous string representation of the BaseItem instance.\n\n        Returns:\n            str: String representation of the BaseItem.\n        \"\"\"\n        return f\"BaseItem(id={self.id!r}, title={self.title!r}, type={self.type!r})\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Returns a user-friendly string representation of the BaseItem instance.\n\n        Returns:\n            str: User-friendly string representation.\n        \"\"\"\n        return f\"{self.title or 'Unnamed Item'} (ID: {self.id}, Type: {self.type})\"\n</code></pre> <p>               Bases: <code>BaseItem</code></p> <p>Represents a table dataset item in the Koordinates system.</p> <p>Inherits from BaseItem and provides methods to interact with table datasets, including querying records, exporting data, and retrieving changesets.</p> <p>Attributes:</p> Name Type Description <code>_supports_changesets</code> <code>bool or None</code> <p>Whether the item supports changesets.</p> <code>_services</code> <code>list or None</code> <p>Cached list of services for this item.</p> <code>_gis</code> <code>GIS</code> <p>The GIS instance this item belongs to.</p> <code>_raw_json</code> <code>dict</code> <p>The raw JSON dictionary representing the item.</p> <code>id</code> <code>str</code> <p>The unique identifier of the item.</p> <code>type</code> <code>str</code> <p>The type of the item (should be 'table').</p> <code>kind</code> <code>str</code> <p>The kind of the item (should be 'table').</p> <code>title</code> <code>str</code> <p>The title of the item.</p> <code>description</code> <code>str</code> <p>The description of the item.</p> <code>_jobs</code> <code>list</code> <p>List of JobResult objects associated with this item.</p> Source code in <code>src\\kapipy\\features\\table_item.py</code> <pre><code>class TableItem(BaseItem):\n    \"\"\"\n    Represents a table dataset item in the Koordinates system.\n\n    Inherits from BaseItem and provides methods to interact with table datasets, including\n    querying records, exporting data, and retrieving changesets.\n\n    Attributes:\n        _supports_changesets (bool or None): Whether the item supports changesets.\n        _services (list or None): Cached list of services for this item.\n        _gis (GIS): The GIS instance this item belongs to.\n        _raw_json (dict): The raw JSON dictionary representing the item.\n        id (str): The unique identifier of the item.\n        type (str): The type of the item (should be 'table').\n        kind (str): The kind of the item (should be 'table').\n        title (str): The title of the item.\n        description (str): The description of the item.\n        _jobs (list): List of JobResult objects associated with this item.\n    \"\"\"\n\n    def __init__(self, gis: \"GIS\", item_dict: dict) -&gt; None:\n        \"\"\"\n        Initializes the TableItem with a dictionary of item details.\n\n        Parameters:\n            gis (GIS): The GIS instance this item belongs to.\n            item_dict (dict): A dictionary containing the item's details, typically from an API response.\n        \"\"\"\n\n        super().__init__(gis, item_dict)\n        self._supports_changesets = None\n        self._services = None\n        logger.debug(f\"Initializing KTableItem with id: {self.id}, title: {self.title}\")\n\n    @property\n    def fields(self) -&gt; list:\n        \"\"\"\n        Returns the fields of the item.\n\n        Returns:\n            list: A list of fields associated with the item.\n        \"\"\"\n        return self._raw_json.get(\"data\", {}).get(\"fields\", [])\n\n    @property\n    def primary_key_fields(self) -&gt; list:\n        \"\"\"\n        Returns the primary key fields of the item.\n\n        Returns:\n            list: A list of primary key fields associated with the item.\n        \"\"\"\n        return self._raw_json.get(\"data\", {}).get(\"primary_key_fields\", [])\n\n    @property\n    def feature_count(self) -&gt; int | None:\n        \"\"\"\n        Returns the number of features in the item.\n\n        Returns:\n            int or None: The number of features associated with the item, or None if not available.\n        \"\"\"\n        return self._raw_json.get(\"data\", {}).get(\"feature_count\", None)\n\n    @property\n    def export_formats(self) -&gt; list:\n        \"\"\"\n        Returns the export formats available for the item.\n\n        Returns:\n            list or None: A list of export formats associated with the item, or None if not available.\n        \"\"\"\n        return self._raw_json.get(\"data\", {}).get(\"export_formats\", None)\n\n    @property\n    def supports_changesets(self) -&gt; bool:\n        \"\"\"\n        Returns whether the item supports changesets.\n\n        Returns:\n            bool: True if the item supports changesets, False otherwise.\n        \"\"\"\n        if self._supports_changesets is None:\n            logger.debug(f\"Checking if item with id: {self.id} supports changesets\")\n            self._supports_changesets = any(\n                service.get(\"key\") == \"wfs-changesets\" for service in self.services\n            )\n\n        return self._supports_changesets\n\n    @property\n    def _wfs_url(self) -&gt; str:\n        \"\"\"\n        Returns the WFS URL for the item.\n\n        Returns:\n            str: The WFS URL associated with the item.\n        \"\"\"\n        return f\"{self._gis._service_url}wfs/\"\n\n    def get_wfs_service(self) -&gt; str:\n        \"\"\"\n        Returns a string that is the URL for the WFS service.\n\n        Returns:\n            str: The URL for the WFS service.\n        \"\"\"\n\n        logger.debug(f\"Creating WFS service for item with id: {self.id}\")\n        wfs_service = self._gis.wfs.operations\n\n    def query_json(self, cql_filter: str = None, **kwargs: Any) -&gt; dict:\n        \"\"\"\n        Executes a WFS query on the item and returns the result as JSON.\n\n        Parameters:\n            cql_filter (str, optional): The CQL filter to apply to the query.\n            **kwargs: Additional parameters for the WFS query.\n\n        Returns:\n            dict: The result of the WFS query in JSON format.\n        \"\"\"\n        logger.debug(f\"Executing WFS query for item with id: {self.id}\")\n\n        result = wfs_features.download_wfs_data(\n            url=self._wfs_url,\n            api_key=self._gis._api_key,\n            typeNames=f\"{self.type}-{self.id}\",\n            cql_filter=cql_filter,\n            **kwargs,\n        )\n\n        return result\n\n    def query(self, cql_filter: str = None, **kwargs: Any) -&gt; dict:\n        \"\"\"\n        Executes a WFS query on the item and returns the result as a DataFrame.\n\n        Parameters:\n            cql_filter (str, optional): The CQL filter to apply to the query.\n            **kwargs: Additional parameters for the WFS query.\n\n        Returns:\n            pandas.DataFrame: The result of the WFS query as a DataFrame.\n        \"\"\"\n        logger.debug(f\"Executing WFS query for item with id: {self.id}\")\n\n        result = self.query_json(cql_filter=cql_filter, **kwargs)\n\n        df = json_to_df(result, fields=self.fields)\n        return df\n\n    def get_changeset_json(\n        self, from_time: str, to_time: str = None, cql_filter: str = None, **kwargs: Any\n    ) -&gt; dict:\n        \"\"\"\n        Retrieves a changeset for the item in JSON format.\n\n        Parameters:\n            from_time (str): The start time for the changeset query, ISO format (e.g., \"2015-05-15T04:25:25.334974\").\n            to_time (str, optional): The end time for the changeset query, ISO format. If not provided, the current time is used.\n            cql_filter (str, optional): The CQL filter to apply to the changeset query.\n            **kwargs: Additional parameters for the WFS query.\n\n        Returns:\n            dict: The changeset data in JSON format.\n\n        Raises:\n            ValueError: If the item does not support changesets.\n        \"\"\"\n\n        if not self.supports_changesets:\n            logger.error(f\"Item with id: {self.id} does not support changesets.\")\n            raise ValueError(\"This item does not support changesets.\")\n\n        if to_time is None:\n            to_time = datetime.now().isoformat()\n        logger.debug(\n            f\"Fetching changeset for item with id: {self.id} from {from_time} to {to_time}\"\n        )\n\n        viewparams = f\"from:{from_time};to:{to_time}\"\n\n        result = wfs_features.download_wfs_data(\n            url=self._wfs_url,\n            api_key=self._gis._api_key,\n            typeNames=f\"{self.type}-{self.id}-changeset\",\n            viewparams=viewparams,\n            cql_filter=cql_filter,\n            **kwargs,\n        )\n\n        return result\n\n    def get_changeset(\n        self, from_time: str, to_time: str = None, cql_filter: str = None, **kwargs: Any\n    ) -&gt; dict:\n        \"\"\"\n        Retrieves a changeset for the item and returns it as a DataFrame.\n\n        Parameters:\n            from_time (str): The start time for the changeset query, ISO format (e.g., \"2015-05-15T04:25:25.334974\").\n            to_time (str, optional): The end time for the changeset query, ISO format. If not provided, the current time is used.\n            cql_filter (str, optional): The CQL filter to apply to the changeset query.\n            **kwargs: Additional parameters for the WFS query.\n\n        Returns:\n            pandas.DataFrame: The changeset data as a DataFrame.\n        \"\"\"\n\n        result = self.get_changeset_json(\n            from_time=from_time, to_time=to_time, cql_filter=cql_filter, **kwargs\n        )\n\n        df = json_to_df(result, fields=self.fields)\n        return df\n\n    @property\n    def services(self) -&gt; list:\n        \"\"\"\n        Returns the services associated with the item.\n\n        Returns:\n            list: A list of services associated with the item.\n        \"\"\"\n\n        if self._services is None:\n            logger.debug(f\"Fetching services for item with id: {self.id}\")\n            url = self._gis._api_url + f\"tables/{self.id}/services/\"\n            self._services = self._gis.get(url)\n        logger.debug(\n            f\"Returning {len(self._services)} services for item with id: {self.id}\"\n        )\n        return self._services\n\n    def reset(self) -&gt; None:\n        \"\"\"\n        Resets the TableItem instance, clearing cached properties.\n        This is useful for refreshing the item state.\n        \"\"\"\n\n        logger.info(f\"Resetting KTableItem with id: {self.id}\")\n        self._supports_changesets = None\n        self._services = None\n        self._raw_json = None\n\n    def _resolve_export_format(self, export_format: str) -&gt; str:\n        \"\"\"\n        Validates if the export format is supported by the item and returns the mimetype.\n\n        Parameters:\n            export_format (str): The format to validate.\n\n        Returns:\n            str: The mimetype of the export format if supported.\n\n        Raises:\n            ValueError: If the export format is not supported by this item.\n        \"\"\"\n\n        logger.debug(\n            f\"Validating export format: {export_format} for item with id: {self.id}\"\n        )\n        mimetype = None\n\n        # check if the export format is either any of the names or mimetypes in the example_formats\n        export_format = export_format.lower()\n\n        # Handle special cases for export formats geopackage and sqlite as it seems a\n        # strange string argument to expect a user to pass in\n        if export_format in (\"geopackage\", \"sqlite\"):\n            export_format = \"GeoPackage / SQLite\".lower()\n\n        for f in self.export_formats:\n            if export_format in (f[\"name\"].lower(), f[\"mimetype\"].lower()):\n                mimetype = f[\"mimetype\"]\n\n        if mimetype is None:\n            raise ValueError(\n                f\"Export format {export_format} is not supported by this item. Refer supported formats using : itm.export_formats\"\n            )\n\n        logger.debug(f\"Resolved export format: {mimetype} from {export_format}\")\n        return mimetype\n\n    def validate_export_request(\n        self,\n        export_format: str,\n        **kwargs: Any,\n    ) -&gt; bool:\n        \"\"\"\n        Validates the export request parameters for the item.\n\n        Parameters:\n            export_format (str): The format to export the item in.\n            **kwargs: Additional parameters for the export request.\n\n        Returns:\n            bool: True if the export request is valid, False otherwise.\n        \"\"\"\n\n        export_format = self._resolve_export_format(export_format)\n\n        # log out all the input parameters including kwargs\n        logger.info(\n            f\"Validating export request for item with id: {self.id}, {export_format=}, {kwargs=}\"\n        )\n\n        return export_features.validate_export_params(\n            self._gis._api_url,\n            self._gis._api_key,\n            self.id,\n            self.type,\n            self.kind,\n            export_format,\n            **kwargs,\n        )\n\n    def export(\n        self,\n        export_format: str,\n        poll_interval: int = 10,\n        timeout: int = 600,\n        **kwargs: Any,\n    ) -&gt; JobResult:\n        \"\"\"\n        Exports the item in the specified format.\n\n        Parameters:\n            export_format (str): The format to export the item in.\n            poll_interval (int, optional): The interval in seconds to poll the export job status. Default is 10 seconds.\n            timeout (int, optional): The maximum time in seconds to wait for the export job to complete. Default is 600 seconds (10 minutes).\n            **kwargs: Additional parameters for the export request.\n\n        Returns:\n            JobResult: A JobResult instance containing the export job details.\n\n        Raises:\n            ValueError: If export validation fails.\n        \"\"\"\n\n        logger.debug(f\"Exporting item with id: {self.id} in format: {export_format}\")\n\n        export_format = self._resolve_export_format(export_format)\n\n        validate_export_request = self.validate_export_request(\n            export_format,\n            **kwargs,\n        )\n\n        if not validate_export_request:\n            logger.error(\n                f\"Export validation failed for item with id: {self.id} in format: {export_format}\"\n            )\n            raise ValueError(\n                f\"Export validation failed for item with id: {self.id} in format: {export_format}\"\n            )\n\n        export_request = export_features.request_export(\n            self._gis._api_url,\n            self._gis._api_key,\n            self.id,\n            self.type,\n            self.kind,\n            export_format,\n            **kwargs,\n        )\n\n        job_result = JobResult(\n            export_request, self._gis, poll_interval=poll_interval, timeout=timeout\n        )\n        self._jobs.append(job_result)\n        logger.info(\n            f\"Export job created for item with id: {self.id}, job id: {job_result.id}\"\n        )\n        return job_result\n\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Returns an unambiguous string representation of the TableItem instance.\n\n        Returns:\n            str: String representation of the TableItem.\n        \"\"\"\n        return f\"TableItem(id={self.id}, title={self.title}, type={self.type}, kind={self.kind})\"\n\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Returns a user-friendly string representation of the TableItem instance.\n\n        Returns:\n            str: User-friendly string representation.\n        \"\"\"\n        return f\"{self.title or 'Unnamed Table'} (ID: {self.id}, Type: {self.type})\"\n</code></pre> <p>               Bases: <code>BaseItem</code></p> <p>Represents a vector dataset item in the Koordinates system.</p> <p>Inherits from BaseItem and provides methods to interact with vector datasets, including querying features, exporting data, and retrieving changesets.</p> <p>Attributes:</p> Name Type Description <code>_supports_changesets</code> <code>bool or None</code> <p>Whether the item supports changesets.</p> <code>_services</code> <code>list or None</code> <p>Cached list of services for this item.</p> <code>_gis</code> <code>GIS</code> <p>The GIS instance this item belongs to.</p> <code>_raw_json</code> <code>dict</code> <p>The raw JSON dictionary representing the item.</p> <code>id</code> <code>str</code> <p>The unique identifier of the item.</p> <code>type</code> <code>str</code> <p>The type of the item (should be 'layer').</p> <code>kind</code> <code>str</code> <p>The kind of the item (should be 'vector').</p> <code>title</code> <code>str</code> <p>The title of the item.</p> <code>description</code> <code>str</code> <p>The description of the item.</p> <code>_jobs</code> <code>list</code> <p>List of JobResult objects associated with this item.</p> Source code in <code>src\\kapipy\\features\\vector_item.py</code> <pre><code>class VectorItem(BaseItem):\n    \"\"\"\n    Represents a vector dataset item in the Koordinates system.\n\n    Inherits from BaseItem and provides methods to interact with vector datasets, including\n    querying features, exporting data, and retrieving changesets.\n\n    Attributes:\n        _supports_changesets (bool or None): Whether the item supports changesets.\n        _services (list or None): Cached list of services for this item.\n        _gis (GIS): The GIS instance this item belongs to.\n        _raw_json (dict): The raw JSON dictionary representing the item.\n        id (str): The unique identifier of the item.\n        type (str): The type of the item (should be 'layer').\n        kind (str): The kind of the item (should be 'vector').\n        title (str): The title of the item.\n        description (str): The description of the item.\n        _jobs (list): List of JobResult objects associated with this item.\n    \"\"\"\n\n    def __init__(self, gis: \"GIS\", item_dict: dict) -&gt; None:\n        \"\"\"\n        Initializes the VectorItem with a dictionary of item details.\n\n        Parameters:\n            gis (GIS): The GIS instance this item belongs to.\n            item_dict (dict): A dictionary containing the item's details, typically from an API response.\n        \"\"\"\n\n        super().__init__(gis, item_dict)\n        self._supports_changesets = None\n        self._services = None\n        logger.debug(\n            f\"Initializing KVectorItem with id: {self.id}, title: {self.title}\"\n        )\n\n    @property\n    def fields(self) -&gt; list:\n        \"\"\"\n        Returns the fields of the item.\n\n        Returns:\n            list: A list of fields associated with the item.\n        \"\"\"\n        return self._raw_json.get(\"data\", {}).get(\"fields\", [])\n\n    @property\n    def epsg(self) -&gt; int | None:\n        \"\"\"\n        Returns the EPSG code of the item.\n\n        Returns:\n            int or None: The EPSG code associated with the item, or None if not available.\n        \"\"\"\n        return self._raw_json.get(\"data\", {}).get(\"crs\", {}).get(\"srid\", None)\n\n    @property\n    def primary_key_fields(self) -&gt; list:\n        \"\"\"\n        Returns the primary key fields of the item.\n\n        Returns:\n            list: A list of primary key fields associated with the item.\n        \"\"\"\n        return self._raw_json.get(\"data\", {}).get(\"primary_key_fields\", [])\n\n    @property\n    def geometry_type(self) -&gt; str | None:\n        \"\"\"\n        Returns the geometry type of the item.\n\n        Returns:\n            str or None: The geometry type associated with the item, or None if not available.\n        \"\"\"\n        return self._raw_json.get(\"data\", {}).get(\"geometry_type\", None)\n\n    @property\n    def feature_count(self) -&gt; int | None:\n        \"\"\"\n        Returns the number of features in the item.\n\n        Returns:\n            int or None: The number of features associated with the item, or None if not available.\n        \"\"\"\n        return self._raw_json.get(\"data\", {}).get(\"feature_count\", None)\n\n    @property\n    def extent(self) -&gt; dict | None:\n        \"\"\"\n        Returns the extent of the item.\n\n        Returns:\n            dict or None: A dictionary containing the extent of the item, or None if not available.\n        \"\"\"\n        return self._raw_json.get(\"data\", {}).get(\"extent\", None)\n\n    @property\n    def export_formats(self) -&gt; list | None:\n        \"\"\"\n        Returns the export formats available for the item.\n\n        Returns:\n            list or None: A list of export formats associated with the item, or None if not available.\n        \"\"\"\n        return self._raw_json.get(\"data\", {}).get(\"export_formats\", None)\n\n    @property\n    def supports_changesets(self) -&gt; bool:\n        \"\"\"\n        Returns whether the item supports changesets.\n\n        Returns:\n            bool: True if the item supports changesets, False otherwise.\n        \"\"\"\n        if self._supports_changesets is None:\n            logger.debug(f\"Checking if item with id: {self.id} supports changesets\")\n            self._supports_changesets = any(\n                service.get(\"key\") == \"wfs-changesets\" for service in self.services\n            )\n\n        return self._supports_changesets\n\n    @property\n    def _wfs_url(self) -&gt; str:\n        \"\"\"\n        Returns the WFS URL for the item.\n\n        Returns:\n            str: The WFS URL associated with the item.\n        \"\"\"\n        return f\"{self._gis._service_url}wfs/\"\n\n    def get_wfs_service(self) -&gt; str:\n        \"\"\"\n        Returns the item's WFS service URL.\n\n        Returns:\n            str: The WFS service URL.\n        \"\"\"\n\n        logger.debug(f\"Creating WFS service for item with id: {self.id}\")\n        wfs_service = self._gis.wfs.operations\n\n    def query_to_json(\n        self,\n        cql_filter: str = None,\n        wkid: int = None,\n        bbox: Union[str, \"gpd.GeoDataFrame\", \"pd.DataFrame\"] = None,\n        **kwargs: Any,\n    ) -&gt; dict:\n        \"\"\"\n        Executes a WFS query on the item and returns the result as JSON.\n\n        Parameters:\n            cql_filter (str, optional): The CQL filter to apply to the query.\n            wkid (int, optional): The spatial reference system code to use for the query.\n            bbox (str or gpd.GeoDataFrame or pd.DataFrame, optional): The bounding box to apply to the query.\n                If a GeoDataFrame or SEDF is provided, it will be converted to a bounding box string in WGS84.\n            **kwargs: Additional parameters for the WFS query.\n\n        Returns:\n            dict: The result of the WFS query in JSON format.\n        \"\"\"\n\n        logger.debug(f\"Executing WFS query for item with id: {self.id}\")\n\n        # Handle bbox\n        if bbox is not None and not isinstance(bbox, str):              \n            bbox = sdf_or_gdf_to_bbox(bbox)\n\n        result = wfs_features.download_wfs_data(\n            url=self._wfs_url,\n            api_key=self._gis._api_key,\n            typeNames=f\"{self.type}-{self.id}\",\n            cql_filter=cql_filter,\n            srsName=f'EPSG:{wkid}' or f\"EPSG:{self.epsg}\" if self.epsg else None,\n            bbox=bbox,\n            **kwargs,\n        )\n\n        return result\n\n    def query(\n        self,\n        cql_filter: str = None,\n        wkid: int = None,\n        bbox: Union[str, \"gpd.GeoDataFrame\", \"pd.DataFrame\"] = None,\n        output_format = None,\n        **kwargs: Any,\n    ) -&gt; \"gpd.GeoDataFrame\":\n        \"\"\"\n        Executes a WFS query on the item and returns the result as a GeoDataFrame, SEDF, or JSON.\n\n        Parameters:\n            cql_filter (str, optional): The CQL filter to apply to the query.\n            wkid (int, optional): The spatial reference system code to use for the query.\n            bbox (str or gpd.GeoDataFrame or pd.DataFrame, optional): The bounding box to apply to the query.\n                If a GeoDataFrame or SEDF is provided, it will be converted to a bounding box string in WGS84.\n            output_format (str, optional): The output format: 'gdf', 'sdf', or 'json'. Defaults to the best available.\n            **kwargs: Additional parameters for the WFS query.\n\n        Returns:\n            gpd.GeoDataFrame or arcgis.features.GeoAccessor or dict: The result of the WFS query as a GeoDataFrame, SEDF, or JSON.\n\n        Raises:\n            ImportError: If the requested output format requires a package that is not installed.\n            ValueError: If the output format is unknown.\n        \"\"\"\n\n        if output_format is None:\n            output_format = get_default_output_format()\n        output_format = output_format.lower()\n        if output_format not in ('sdf', 'gdf', 'geodataframe', 'json', 'geojson'):\n            raise ValueError(f'Unknown output format: {output_format}')\n\n        wkid = wkid if wkid is not None else self.epsg\n\n        result = self.query_to_json(\n            cql_filter=cql_filter,\n            wkid=wkid,\n            bbox=bbox,\n            **kwargs,\n        )\n\n        if output_format == 'sdf':\n            return geojson_to_sdf(result, wkid=wkid, fields=self.fields)\n        elif output_format in ('gdf', 'geodataframe'):\n            return geojson_to_gdf(result, wkid=wkid, fields=self.fields)\n        return result\n\n\n    def changeset_to_json(\n        self,\n        from_time: str,\n        to_time: str = None,\n        wkid = None,\n        cql_filter: str = None,\n        bbox: Union[str, \"gpd.GeoDataFrame\", \"pd.DataFrame\"] = None,\n        **kwargs: Any,\n    ) -&gt; dict:\n        \"\"\"\n        Retrieves a changeset for the item in JSON format.\n\n        Parameters:\n            from_time (str): The start time for the changeset query, ISO format (e.g., \"2015-05-15T04:25:25.334974\").\n            to_time (str, optional): The end time for the changeset query, ISO format. If not provided, the current time is used.\n            cql_filter (str, optional): The CQL filter to apply to the changeset query.\n            bbox (str or gpd.GeoDataFrame, optional): The bounding box to apply to the changeset query.\n                If a GeoDataFrame is provided, it will be converted to a bounding box string in WGS84.\n            **kwargs: Additional parameters for the WFS query.\n\n        Returns:\n            dict: The changeset data in JSON format.\n\n        Raises:\n            ValueError: If the item does not support changesets.\n        \"\"\"\n\n        if not self.supports_changesets:\n            logger.error(f\"Item with id: {self.id} does not support changesets.\")\n            raise ValueError(\"This item does not support changesets.\")\n\n        if to_time is None:\n            to_time = datetime.now().isoformat()\n        logger.debug(\n            f\"Fetching changeset for item with id: {self.id} from {from_time} to {to_time}\"\n        )\n\n        viewparams = f\"from:{from_time};to:{to_time}\"\n\n        # Handle bbox\n        if bbox is not None and not isinstance(bbox, str):              \n            bbox = sdf_or_gdf_to_bbox(bbox)\n\n        result = wfs_features.download_wfs_data(\n            url=self._wfs_url,\n            api_key=self._gis._api_key,\n            typeNames=f\"layer-{self.id}-changeset\",\n            viewparams=viewparams,\n            cql_filter=cql_filter,\n            srsName=f'EPSG:{wkid}' or f\"EPSG:{self.epsg}\" if self.epsg else None,\n            bbox=bbox,\n            **kwargs,\n        )\n        return result\n\n    def changeset(\n        self,\n        from_time: str,\n        to_time: str = None,\n        wkid: int = None,\n        cql_filter: str = None,\n        bbox: Union[str, \"gpd.GeoDataFrame\", \"pd.DataFrame\"] = None,\n        output_format = None,\n        **kwargs: Any,\n    ) -&gt; \"gpd.GeoDataFrame\":\n        \"\"\"\n        Retrieves a changeset for the item and returns it as a GeoDataFrame, SEDF, or JSON.\n\n        Parameters:\n            from_time (str): The start time for the changeset query, ISO format (e.g., \"2015-05-15T04:25:25.334974\").\n            to_time (str, optional): The end time for the changeset query, ISO format. If not provided, the current time is used.\n            wkid (int, optional): The spatial reference system code to use for the query.\n            cql_filter (str, optional): The CQL filter to apply to the changeset query.\n            bbox (str or gpd.GeoDataFrame or pd.DataFrame, optional): The bounding box to apply to the changeset query.\n                If a GeoDataFrame or SEDF is provided, it will be converted to a bounding box string in WGS84.\n            output_format (str, optional): The output format: 'gdf', 'sdf', or 'json'. Defaults to the best available.\n            **kwargs: Additional parameters for the WFS query.\n\n        Returns:\n            gpd.GeoDataFrame or arcgis.features.GeoAccessor or dict: The changeset data as a GeoDataFrame, SEDF, or JSON.\n\n        Raises:\n            ImportError: If the requested output format requires a package that is not installed.\n            ValueError: If the output format is unknown.\n        \"\"\"\n\n        wkid = wkid if wkid is not None else self.epsg\n\n        if output_format is None:\n            output_format = get_default_output_format()\n        output_format = output_format.lower()\n        if output_format not in ('sdf', 'gdf', 'geodataframe', 'json', 'geojson'):\n            raise ValueError(f'Unknown output format: {output_format}')\n\n        result = self.changeset_to_json(\n            from_time=from_time,\n            to_time=to_time,\n            wkid=wkid,\n            cql_filter=cql_filter,\n            bbox=bbox,\n            **kwargs,\n        )\n\n        if output_format == 'sdf':\n            return geojson_to_sdf(result, wkid=wkid, fields=self.fields)\n        elif output_format in ('gdf', 'geodataframe'):\n            return geojson_to_gdf(result, wkid=wkid, fields=self.fields)\n        return result\n\n    @property\n    def services(self) -&gt; list:\n        \"\"\"\n        Returns the services associated with the item.\n\n        Returns:\n            list: A list of services associated with the item.\n        \"\"\"\n\n        if self._services is None:\n            logger.debug(f\"Fetching services for item with id: {self.id}\")\n            url = self._gis._api_url + f\"layers/{self.id}/services/\"\n            self._services = self._gis.get(url)\n        logger.debug(\n            f\"Returning {len(self._services)} services for item with id: {self.id}\"\n        )\n        return self._services\n\n    def reset(self) -&gt; None:\n        \"\"\"\n        Resets the VectorItem instance, clearing cached properties.\n        This is useful for refreshing the item state.\n        \"\"\"\n        logger.debug(f\"Resetting KVectorItem with id: {self.id}\")\n        self._supports_changesets = None\n        self._services = None\n        self._raw_json = None\n\n    def _resolve_export_format(self, export_format: str) -&gt; str:\n        \"\"\"\n        Validates if the export format is supported by the item and returns the mimetype.\n\n        Parameters:\n            export_format (str): The format to validate.\n\n        Returns:\n            str: The mimetype of the export format if supported.\n\n        Raises:\n            ValueError: If the export format is not supported by this item.\n        \"\"\"\n\n        logger.debug(\n            f\"Validating export format: {export_format} for item with id: {self.id}\"\n        )\n        mimetype = None\n\n        # check if the export format is either any of the names or mimetypes in the example_formats\n        export_format = export_format.lower()\n\n        # Handle special cases for export formats geopackage and sqlite as it seems a\n        # strange string argument to expect a user to pass in\n        if export_format in (\"geopackage\", \"sqlite\"):\n            export_format = \"GeoPackage / SQLite\".lower()\n\n        for f in self.export_formats:\n            if export_format in (f[\"name\"].lower(), f[\"mimetype\"].lower()):\n                mimetype = f[\"mimetype\"]\n\n        if mimetype is None:\n            raise ValueError(\n                f\"Export format {export_format} is not supported by this item. Refer supported formats using : itm.export_formats\"\n            )\n\n        logger.debug(f\"Resolved export format: {mimetype} from {export_format}\")\n        return mimetype\n\n    def _validate_export_request(\n        self,\n        export_format: str,\n        crs: str = None,\n        extent: dict = None,\n        **kwargs: Any,\n    ) -&gt; bool:\n        \"\"\"\n        Validates the export request parameters for the item.\n\n        Parameters:\n            export_format (str): The format to export the item in.\n            crs (str, optional): The coordinate reference system to use for the export.\n            extent (dict, optional): The extent to use for the export. Should be a GeoJSON dictionary.\n            **kwargs: Additional parameters for the export request.\n\n        Returns:\n            bool: True if the export request is valid, False otherwise.\n        \"\"\"\n\n        export_format = self._resolve_export_format(export_format)\n\n        # log out all the input parameters including kwargs\n        logger.debug(\n            f\"Validating export request for item with id: {self.id}, {export_format=}, {crs=}, {extent=},  {kwargs=}\"\n        )\n\n        return export_features.validate_export_params(\n            self._gis._api_url,\n            self._gis._api_key,\n            self.id,\n            self.type,\n            self.kind,\n            export_format,\n            crs,\n            extent,\n            **kwargs,\n        )\n\n    def export(\n        self,\n        export_format: str,\n        wkid: int = None,\n        extent: Union[dict, \"gpd.GeoDataFrame\", \"pd.DataFrame\"] = None,\n        poll_interval: int = 10,\n        timeout: int = 600,\n        **kwargs: Any,\n    ) -&gt; JobResult:\n        \"\"\"\n        Exports the item in the specified format.\n\n        Parameters:\n            export_format (str): The format to export the item in.\n            wkid (int, optional): The coordinate reference system code to use for the export.\n            extent (dict or gpd.GeoDataFrame or pd.DataFrame, optional): The extent to use for the export. Should be a GeoJSON dictionary, GeoDataFrame, or SEDF.\n            poll_interval (int, optional): The interval in seconds to poll the export job status. Default is 10 seconds.\n            timeout (int, optional): The maximum time in seconds to wait for the export job to complete. Default is 600 seconds (10 minutes).\n            **kwargs: Additional parameters for the export request.\n\n        Returns:\n            JobResult: A JobResult instance containing the export job details.\n\n        Raises:\n            ValueError: If export validation fails.\n        \"\"\"\n\n        logger.debug(f\"Exporting item with id: {self.id} in format: {export_format}\")\n\n        wkid = wkid if wkid is not None else self.epsg\n        crs = f'EPSG:{wkid}'\n\n        if extent is not None:\n            extent = sdf_or_gdf_to_single_polygon_geojson(extent)\n\n        export_format = self._resolve_export_format(export_format)\n\n        validate_export_request = self._validate_export_request(\n            export_format,\n            crs=crs,\n            extent=extent,\n            **kwargs,\n        )\n\n        if not validate_export_request:\n            logger.error(\n                f\"Export validation failed for item with id: {self.id} in format: {export_format}\"\n            )\n            raise ValueError(\n                f\"Export validation failed for item with id: {self.id} in format: {export_format}\"\n            )\n\n        export_request = export_features.request_export(\n            self._gis._api_url,\n            self._gis._api_key,\n            self.id,\n            self.type,\n            self.kind,\n            export_format,\n            crs=crs,\n            extent=extent,\n            **kwargs,\n        )\n\n        job_result = JobResult(\n            export_request, self._gis, poll_interval=poll_interval, timeout=timeout\n        )\n        self._jobs.append(job_result)\n        logger.debug(\n            f\"Export job created for item with id: {self.id}, job id: {job_result.id}\"\n        )\n        return job_result\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Returns an unambiguous string representation of the VectorItem instance.\n\n        Returns:\n            str: String representation of the VectorItem.\n        \"\"\"\n        return f\"VectorItem(id={self.id}, title={self.title}, type={self.type}, kind={self.kind})\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Returns a user-friendly string representation of the VectorItem instance.\n\n        Returns:\n            str: User-friendly string representation.\n        \"\"\"\n        return f\"{self.title or 'Unnamed Vector'} (ID: {self.id}, Type: {self.type})\"\n</code></pre> <p>Manages content for a GIS instance.</p> <p>Provides methods to search for, retrieve, and instantiate Koordinates items (layers, tables, etc.) based on their IDs or URLs.</p> <p>Attributes:</p> Name Type Description <code>_gis</code> <code>GIS</code> <p>The GIS instance this manager is associated with.</p> Source code in <code>src\\kapipy\\gis\\content_manager.py</code> <pre><code>class ContentManager:\n    \"\"\"\n    Manages content for a GIS instance.\n\n    Provides methods to search for, retrieve, and instantiate Koordinates items (layers, tables, etc.)\n    based on their IDs or URLs.\n\n    Attributes:\n        _gis (GIS): The GIS instance this manager is associated with.\n    \"\"\"\n\n    def __init__(self, gis: \"GIS\") -&gt; None:\n        \"\"\"\n        Initializes the ContentManager with a GIS instance.\n\n        Parameters:\n            gis (GIS): The GIS instance to manage content for.\n        \"\"\"\n        self._gis = gis\n\n    def _search_by_id(self, id: str) -&gt; dict:\n        \"\"\"\n        Searches for content by ID in the GIS.\n\n        Parameters:\n            id (str): The ID of the content to search for.\n\n        Returns:\n            dict: The search result(s) from the GIS API.\n        \"\"\"\n\n        # Example: https://data.linz.govt.nz/services/api/v1.x/data/?id=51571\n        url = urljoin(self._gis._api_url, f\"data/?id={id}\")\n        response = self._gis.get(url)\n        return response\n\n    def get(self, id: str) -&gt; dict:\n        \"\"\"\n        Retrieves and instantiates a content item by ID from the GIS.\n\n        Parameters:\n            id (str): The ID of the content to retrieve.\n\n        Returns:\n            VectorItem or TableItem or None: The instantiated item, depending on its kind, or None if not found.\n\n        Raises:\n            BadRequest: If the content is not found or the request is invalid.\n            UnknownItemTypeError: If the item kind is not supported.\n            ServerError: If the item does not have a URL.\n        \"\"\"\n\n        search_result = self._search_by_id(id)\n        if not search_result or \"error\" in search_result:\n            raise BadRequest(f\"Content with id {id} not found or invalid request.\")\n        if len(search_result) == 0:\n            return None\n        elif len(search_result) &gt; 1:\n            raise BadRequest(\n                f\"Multiple contents found for id {id}. Please refine your search.\"\n            )\n\n        # Assuming the first item is the desired content\n        item_json = search_result[0]\n        if \"url\" not in item_json:\n            raise ServerError(f\"Item with id {id} does not have a URL.\")\n        item_details = self._gis.get(item_json.get(\"url\"))\n\n        # Based on the kind of item, return the appropriate item class.\n        if item_details.get(\"kind\") == \"vector\":\n            from kapipy.features import VectorItem\n\n            item = VectorItem(self._gis, item_details)\n        elif item_details.get(\"kind\") == \"table\":\n            from kapipy.features import TableItem\n\n            item = TableItem(self._gis, item_details)\n        else:\n            raise UnknownItemTypeError(\n                f\"Unsupported item kind: {item_details.get('kind')}\"\n            )\n\n        return item\n\n    def download(\n        self, jobs: list[\"JobResults\"], folder: str, poll_interval=10\n    ) -&gt; list[\"JobResults\"]:\n\n        \"\"\"\n        Downloads all exports from a list of jobs.\n        Polls the jobs until they are finished. As soon as it encounters a finished job,\n        it pauses polling and downloads that file, then resumes polling the remainder.\n\n        Parameters:\n            jobs (list[JobResult]): The list of job result objects to download.\n            folder (str): The output folder where files will be saved.\n            poll_interval (int, optional): The interval in seconds to poll the jobs. Default is 10.\n\n        Returns:\n            list[JobResult]: The list of job result objects after download.\n        \"\"\"\n\n        pending_jobs = list(jobs)\n\n        while pending_jobs:\n            logger.info(\"Polling export jobs...\")\n            time.sleep(poll_interval)\n\n            for job in pending_jobs[:]:  # iterate over a copy\n                state = job.state\n\n                if state != \"processing\":\n                    job.download(folder=folder)\n                    pending_jobs.remove(job)\n\n            logger.info(f\"{len(pending_jobs)} jobs remaining...\")\n\n        logger.info(\"All jobs completed and downloaded.\")\n        return jobs\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Returns an unambiguous string representation of the ContentManager instance.\n\n        Returns:\n            str: String representation of the ContentManager.\n        \"\"\"\n        return f\"ContentManager(gis={repr(self._gis)})\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Returns a user-friendly string representation of the ContentManager instance.\n\n        Returns:\n            str: User-friendly string representation.\n        \"\"\"\n        return f\"ContentManager for GIS: {getattr(self._gis, 'name', None) or getattr(self._gis, 'url', 'Unknown')}\"\n</code></pre> <p>Represents the result of an asynchronous export or processing job.</p> <p>Provides methods to poll for job completion, retrieve job status, and download results. The download and download_async methods return a DownloadResult object containing detailed metadata about the downloaded file. Download metadata is also stored as attributes on the JobResult instance after a successful download.</p> <p>Attributes:</p> Name Type Description <code>_initial_payload</code> <code>dict</code> <p>The initial job payload from the API.</p> <code>_job_url</code> <code>str</code> <p>The URL to poll for job status.</p> <code>_id</code> <code>int</code> <p>The unique identifier of the job.</p> <code>_poll_interval</code> <code>int</code> <p>Polling interval in seconds.</p> <code>_timeout</code> <code>int</code> <p>Maximum time to wait for job completion in seconds.</p> <code>_last_response</code> <code>dict</code> <p>The most recent job status response.</p> <code>_gis</code> <code>GIS</code> <p>The GIS instance associated with this job.</p> <code>#</code> <code>Populated after download</code> <code>download_folder</code> <code>str</code> <p>The directory where the file was saved.</p> <code>download_filename</code> <code>str</code> <p>The name of the downloaded file.</p> <code>download_file_path</code> <code>str</code> <p>The full path to the downloaded file.</p> <code>download_file_size_bytes</code> <code>int</code> <p>The size of the downloaded file in bytes.</p> <code>download_completed_at</code> <code>float</code> <p>The timestamp when the download completed.</p> <code>download_resolved_url</code> <code>str</code> <p>The final resolved URL after redirects.</p> <code>download_checksum</code> <code>str | None</code> <p>The SHA256 checksum of the downloaded file.</p> Source code in <code>src\\kapipy\\gis\\job_result.py</code> <pre><code>class JobResult:\n    \"\"\"\n    Represents the result of an asynchronous export or processing job.\n\n    Provides methods to poll for job completion, retrieve job status, and download results.\n    The download and download_async methods return a DownloadResult object containing\n    detailed metadata about the downloaded file. Download metadata is also stored as\n    attributes on the JobResult instance after a successful download.\n\n    Attributes:\n        _initial_payload (dict): The initial job payload from the API.\n        _job_url (str): The URL to poll for job status.\n        _id (int): The unique identifier of the job.\n        _poll_interval (int): Polling interval in seconds.\n        _timeout (int): Maximum time to wait for job completion in seconds.\n        _last_response (dict): The most recent job status response.\n        _gis (GIS): The GIS instance associated with this job.\n\n        # Populated after download:\n        download_folder (str): The directory where the file was saved.\n        download_filename (str): The name of the downloaded file.\n        download_file_path (str): The full path to the downloaded file.\n        download_file_size_bytes (int): The size of the downloaded file in bytes.\n        download_completed_at (float): The timestamp when the download completed.\n        download_resolved_url (str): The final resolved URL after redirects.\n        download_checksum (str | None): The SHA256 checksum of the downloaded file.\n    \"\"\"\n\n    def __init__(\n        self,\n        payload: dict,\n        gis: \"GIS\",\n        poll_interval: int = 10,\n        timeout: int = 600,\n    ) -&gt; None:\n        \"\"\"\n        Initializes the JobResult instance.\n\n        Parameters:\n            payload (dict): The job payload, typically from an API response.\n            gis (GIS): The GIS instance associated with this job.\n            poll_interval (int, optional): Interval in seconds to poll the job status. Default is 10.\n            timeout (int, optional): Maximum time in seconds to wait for the job to complete. Default is 600.\n        \"\"\"\n\n        self._initial_payload = payload\n        self._job_url = payload[\"url\"]\n        self._id = payload[\"id\"]\n        self._poll_interval = poll_interval\n        self._timeout = timeout\n        self._last_response = payload\n        self._gis = gis\n\n\n    @property\n    def id(self) -&gt; int:\n        return self._id\n\n    @property\n    def name(self) -&gt; str:\n        \"\"\"Returns the name of the job.\"\"\"\n        return self._last_response.get(\"name\", \"unknown_name\")\n\n    @property\n    def download_url(self) -&gt; str | None:\n        return self._last_response.get(\"download_url\")\n\n    @property\n    def status(self) -&gt; JobStatus:\n        \"\"\"\n        Refreshes and returns the current job status.\n\n        Returns:\n            JobStatus: The state and progress of the job.\n        \"\"\"\n\n        self._refresh_sync()\n        return JobStatus({\n            state: self._last_response.get(\"state\"),\n            progress: self._last_response.get(\"progress\", None),\n        })\n\n    @property\n    def state(self) -&gt; str:\n        \"\"\"\n        Returns the current state of the job.\n\n        Returns:\n            str: The job state. Possible values include 'complete', 'processing', 'cancelled', 'error', 'gone'.\n        \"\"\"\n\n        self._refresh_sync()\n        return self._last_response.get(\"state\")\n\n\n    @property\n    def progress(self) -&gt; float | None:\n        \"\"\"\n        Returns the progress of the job as a percentage.\n\n        Returns:\n            float | None: The progress value, or None if not available.\n        \"\"\"\n\n        self._refresh_sync()\n        return self._last_response.get(\"progress\", None)\n\n    @property\n    def created_at(self) -&gt; str | None:\n        \"\"\"\n        Returns the creation time of the job.\n\n        Returns:\n            str | None: The creation timestamp, or None if not available.\n        \"\"\"\n\n        return self._last_response.get(\"created_at\", None)\n\n    def to_dict(self) -&gt; dict:\n        \"\"\"\n        Returns the most recent job status response as a dictionary.\n\n        Returns:\n            dict: The most recent job status response.\n        \"\"\"\n        return self._last_response\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Returns a user-friendly string representation of the JobResult.\n\n        Returns:\n            str: User-friendly string representation.\n        \"\"\"\n\n        self._refresh_sync()\n        return (\n            f\"JobResult(id={self.id}, name='{self.name}', \"\n            f\"status='{self._last_response.get('state')}', \"\n            f\"progress={self.progress})\"\n        )\n\n    def _refresh_sync(self) -&gt; None:\n        \"\"\"\n        Refreshes the job status using synchronous HTTP via the GIS instance.\n\n        Returns:\n            None\n        \"\"\"\n        self._last_response = self._gis.get(self._job_url)\n\n\n    def output(self) -&gt; dict:\n        \"\"\"\n        Blocks until the job completes, then returns the final job response.\n\n        Returns:\n            dict: The final job response after completion.\n\n        Raises:\n            TimeoutError: If the job does not complete within the timeout.\n            RuntimeError: If the job fails or is cancelled.\n        \"\"\"\n\n        start = time.time()\n\n        while True:            \n            state = self._last_response.get(\"state\")\n            if state != \"processing\":\n                break\n\n            if (time.time() - start) &gt; self._timeout:\n                raise TimeoutError(\n                    f\"Export job {self._id} did not complete within timeout.\"\n                )\n\n            time.sleep(self._poll_interval)\n            self._refresh_sync()\n\n        if self._last_response.get(\"state\") != \"complete\":\n            raise RuntimeError(\n                f\"Export job {self._id} failed with state: {self._last_response.get('state')}\"\n            )\n\n        return self._last_response\n\n\n    def download(self, folder: str, file_name: str | None = None) -&gt; DownloadResult:\n        \"\"\"\n        Waits for the job to finish, then downloads the file synchronously.\n\n        Parameters:\n            folder (str): The folder where the file will be saved.\n            file_name (str, optional): The name of the file to save. If None, uses the job name.\n\n        Returns:\n            DownloadResult: Object containing details about the downloaded file.\n\n        Raises:\n            ValueError: If the download URL is not available.\n        \"\"\"\n\n        self.output()  # ensure job is complete\n        if not self.download_url:\n            raise ValueError(\n                \"Download URL not available. Job may not have completed successfully.\"\n            )\n\n        file_name = f\"{file_name}.zip\" if file_name else f\"{self.name}.zip\"\n        file_path = os.path.join(folder, file_name)\n        if not os.path.exists(folder):\n            os.makedirs(folder, exist_ok=True)\n\n        headers = {\"Authorization\": f\"key {self._gis._api_key}\"}\n\n        with httpx.Client(follow_redirects=True) as client:\n            resp = client.get(self.download_url, headers=headers, follow_redirects=True)\n            resp.raise_for_status()\n            final_url = str(resp.url)\n\n            with client.stream(\"GET\", final_url) as r, open(file_path, \"wb\") as f:\n                r.raise_for_status()\n                for chunk in r.iter_bytes():\n                    f.write(chunk)\n\n        file_size_bytes = os.path.getsize(file_path)\n        checksum = None\n        try:\n            with open(file_path, \"rb\") as f:\n                checksum = hashlib.sha256(f.read()).hexdigest()\n        except Exception:\n            pass\n        completed_at = time.time()\n\n        # Set as attributes on the JobResult instance\n        self.download_folder = folder\n        self.download_filename = file_name\n        self.download_file_path = file_path\n        self.download_file_size_bytes = file_size_bytes\n        self.download_completed_at = completed_at\n        self.download_resolved_url = final_url\n        self.download_checksum = checksum\n\n        return DownloadResult(\n            folder=folder,\n            filename=file_name,\n            file_path=file_path,\n            file_size_bytes=file_size_bytes,\n            download_url=self.download_url,\n            final_url=final_url,\n            job_id=self._id,\n            completed_at=completed_at,\n            checksum=checksum,\n        )\n</code></pre> <p>Contains metadata about a completed file download from a Koordinates export job.</p> <p>Returned by JobResult.download and JobResult.download_async, this class provides detailed information about the downloaded file and its context.</p> <p>Attributes:</p> Name Type Description <code>folder</code> <code>str</code> <p>Directory where the file was saved.</p> <code>filename</code> <code>str</code> <p>Name of the downloaded file (without path).</p> <code>file_path</code> <code>str</code> <p>Full path to the downloaded file.</p> <code>file_size_bytes</code> <code>int</code> <p>Size of the downloaded file in bytes.</p> <code>download_url</code> <code>str</code> <p>Original download URL provided by the job.</p> <code>final_url</code> <code>str</code> <p>Final resolved URL after redirects (e.g., S3 location).</p> <code>job_id</code> <code>int</code> <p>Unique identifier of the export job.</p> <code>completed_at</code> <code>float</code> <p>Timestamp (seconds since epoch) when the download completed.</p> <code>checksum</code> <code>str | None</code> <p>SHA256 checksum of the downloaded file, or None if unavailable.</p> Source code in <code>src\\kapipy\\gis\\job_result.py</code> <pre><code>@dataclass\nclass DownloadResult:\n    \"\"\"\n    Contains metadata about a completed file download from a Koordinates export job.\n\n    Returned by JobResult.download and JobResult.download_async, this class provides\n    detailed information about the downloaded file and its context.\n\n    Attributes:\n        folder (str): Directory where the file was saved.\n        filename (str): Name of the downloaded file (without path).\n        file_path (str): Full path to the downloaded file.\n        file_size_bytes (int): Size of the downloaded file in bytes.\n        download_url (str): Original download URL provided by the job.\n        final_url (str): Final resolved URL after redirects (e.g., S3 location).\n        job_id (int): Unique identifier of the export job.\n        completed_at (float): Timestamp (seconds since epoch) when the download completed.\n        checksum (str | None): SHA256 checksum of the downloaded file, or None if unavailable.\n    \"\"\"\n\n    folder: str\n    filename: str\n    file_path: str\n    file_size_bytes: int\n    download_url: str\n    final_url: str\n    job_id: int\n    completed_at: float\n    checksum: str | None = None\n</code></pre>"},{"location":"reference/#kapipy.gis.GIS.content","title":"<code>content</code>  <code>property</code>","text":"<p>Returns the ContentManager instance for this server.</p> <p>Returns:</p> Name Type Description <code>ContentManager</code> <code>ContentManager</code> <p>The content manager associated with this server.</p>"},{"location":"reference/#kapipy.gis.GIS.__init__","title":"<code>__init__(name=None, url=None, api_key=None, api_version=DEFAULT_API_VERSION)</code>","text":"<p>Initializes the GIS instance with the base URL, API version, and API key.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the Koordinates portal (e.g., 'linz'). If provided, overrides url.</p> <code>None</code> <code>url</code> <code>str</code> <p>The base URL of the Koordinates server. Used if name is not provided.</p> <code>None</code> <code>api_key</code> <code>str</code> <p>The API key for authenticating with the Koordinates server.</p> <code>None</code> <code>api_version</code> <code>str</code> <p>The API version to use. Defaults to 'v1.x'.</p> <code>DEFAULT_API_VERSION</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the portal name is not recognized or if api_key is not provided.</p> Source code in <code>src\\kapipy\\gis\\__init__.py</code> <pre><code>def __init__(\n    self,\n    name=None,\n    url=None,\n    api_key=None,\n    api_version=DEFAULT_API_VERSION,\n) -&gt; None:\n    \"\"\"\n    Initializes the GIS instance with the base URL, API version, and API key.\n\n    Parameters:\n        name (str, optional): The name of the Koordinates portal (e.g., 'linz'). If provided, overrides url.\n        url (str, optional): The base URL of the Koordinates server. Used if name is not provided.\n        api_key (str): The API key for authenticating with the Koordinates server.\n        api_version (str, optional): The API version to use. Defaults to 'v1.x'.\n\n    Raises:\n        ValueError: If the portal name is not recognized or if api_key is not provided.\n    \"\"\"\n\n    if name and PORTAL_DETAILS.get(name.lower(), None) is None:\n        raise ValueError(\"Supplied portal name is not included in default list.\")\n    if name:\n        self.name = PORTAL_DETAILS.get(name.lower()).get(\"name\")\n        self.url = PORTAL_DETAILS.get(name.lower()).get(\"url\")\n    self.url = (\n        self.url if self.url.endswith(\"/\") else f\"{self.url}/\"\n    )  # ensure trailing slash\n    self._api_version = api_version\n    self._content_manager = None\n    self._wfs_manager = None\n    self._api_key = api_key\n    if not self._api_key:\n        raise ValueError(\"API key must be provided.\")\n    logger.debug(f\"GIS initialized with URL: {self.url}\")\n</code></pre>"},{"location":"reference/#kapipy.gis.GIS.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns an unambiguous string representation of the GIS instance.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of the GIS instance.</p> Source code in <code>src\\kapipy\\gis\\__init__.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Returns an unambiguous string representation of the GIS instance.\n\n    Returns:\n        str: String representation of the GIS instance.\n    \"\"\"\n    return (\n        f\"GIS(name={self.name!r}, url={self.url!r}, api_key={'***' if self._api_key else None}, \"\n        f\"api_version={self._api_version!r})\"\n    )\n</code></pre>"},{"location":"reference/#kapipy.gis.GIS.__str__","title":"<code>__str__()</code>","text":"<p>Returns a user-friendly string representation of the GIS instance.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>User-friendly string representation.</p> Source code in <code>src\\kapipy\\gis\\__init__.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Returns a user-friendly string representation of the GIS instance.\n\n    Returns:\n        str: User-friendly string representation.\n    \"\"\"\n    return f\"GIS: {self.name or 'Custom'} at {self.url} (API {self._api_version})\"\n</code></pre>"},{"location":"reference/#kapipy.gis.GIS.get","title":"<code>get(url, params=None)</code>","text":"<p>Makes a synchronous GET request to the specified URL with the provided parameters. Injects the API key into the request headers.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL to send the GET request to.</p> required <code>params</code> <code>dict</code> <p>Query parameters to include in the request. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The JSON-decoded response from the server.</p> <p>Raises:</p> Type Description <code>BadRequest</code> <p>If the request fails with a 400 status code.</p> <code>ServerError</code> <p>For other HTTP errors or request exceptions.</p> Source code in <code>src\\kapipy\\gis\\__init__.py</code> <pre><code>def get(self, url: str, params: dict = None) -&gt; dict:\n    \"\"\"\n    Makes a synchronous GET request to the specified URL with the provided parameters.\n    Injects the API key into the request headers.\n\n    Parameters:\n        url (str): The URL to send the GET request to.\n        params (dict, optional): Query parameters to include in the request. Defaults to None.\n\n    Returns:\n        dict: The JSON-decoded response from the server.\n\n    Raises:\n        BadRequest: If the request fails with a 400 status code.\n        ServerError: For other HTTP errors or request exceptions.\n    \"\"\"\n\n    headers = {\"Authorization\": f\"key {self._api_key}\"}\n    logger.debug(f\"Making kserver GET request to {url} with params {params}\")\n    try:\n        response = httpx.get(url, headers=headers, params=params, timeout=30)\n    except httpx.RequestError as exc:\n        logger.error(f\"An error occurred while requesting {exc.request.url!r}.\")\n        raise ServerError(str(exc)) from exc\n\n    if response.status_code == 400:\n        raise BadRequest(response.text)\n    response.raise_for_status()\n    return response.json()\n</code></pre>"},{"location":"reference/#kapipy.gis.GIS.reset","title":"<code>reset()</code>","text":"<p>Resets the GIS instance, forcing the content manager and WFS manager to reinitialize the next time they are accessed. This is useful if the API key or other configurations change.</p> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src\\kapipy\\gis\\__init__.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"\n    Resets the GIS instance, forcing the content manager and WFS manager\n    to reinitialize the next time they are accessed. This is useful if the API key\n    or other configurations change.\n\n    Returns:\n        None\n    \"\"\"\n\n    self._content_manager = None\n    self._wfs_manager = None\n    logger.info(\"KServer instance reset.\")\n</code></pre>"},{"location":"reference/#kapipy.gis.base_item.BaseItem.__getattr__","title":"<code>__getattr__(item)</code>","text":"<p>Provides dynamic attribute access for the item.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>The name of the attribute to access.</p> required <p>Returns:</p> Name Type Description <code>object</code> <code>object</code> <p>The value of the requested attribute.</p> <p>Raises:</p> Type Description <code>AttributeError</code> <p>If the attribute does not exist in the item.</p> Source code in <code>src\\kapipy\\gis\\base_item.py</code> <pre><code>def __getattr__(self, item) -&gt; object:\n    \"\"\"\n    Provides dynamic attribute access for the item.\n\n    Parameters:\n        item (str): The name of the attribute to access.\n\n    Returns:\n        object: The value of the requested attribute.\n\n    Raises:\n        AttributeError: If the attribute does not exist in the item.\n    \"\"\"\n\n    attr = self._raw_json.get(item, None)\n    if attr is None:\n        raise AttributeError(f\"{self.__class__.__name__} has no attribute '{item}'\")\n    return attr\n</code></pre>"},{"location":"reference/#kapipy.gis.base_item.BaseItem.__init__","title":"<code>__init__(gis, item_dict)</code>","text":"<p>Initializes the BaseItem instance from a dictionary returned from the API.</p> <p>Parameters:</p> Name Type Description Default <code>gis</code> <code>GIS</code> <p>The GIS instance that this item belongs to.</p> required <code>item_dict</code> <code>dict</code> <p>A dictionary containing the item's details, typically from an API response.</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src\\kapipy\\gis\\base_item.py</code> <pre><code>def __init__(self, gis: \"GIS\", item_dict: dict) -&gt; None:\n    \"\"\"\n    Initializes the BaseItem instance from a dictionary returned from the API.\n\n    Parameters:\n        gis (GIS): The GIS instance that this item belongs to.\n        item_dict (dict): A dictionary containing the item's details, typically from an API response.\n\n    Returns:\n        None\n    \"\"\"\n\n    self._gis = gis\n    self._raw_json = item_dict\n    self.id = item_dict.get(\"id\")\n    self.url = item_dict.get(\"url\")\n    self.type = item_dict.get(\"type\")\n    self.kind = item_dict.get(\"kind\")\n    self.title = item_dict.get(\"title\")\n    self.description = item_dict.get(\"description\")\n    self._jobs = []\n</code></pre>"},{"location":"reference/#kapipy.gis.base_item.BaseItem.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns an unambiguous string representation of the BaseItem instance.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of the BaseItem.</p> Source code in <code>src\\kapipy\\gis\\base_item.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Returns an unambiguous string representation of the BaseItem instance.\n\n    Returns:\n        str: String representation of the BaseItem.\n    \"\"\"\n    return f\"BaseItem(id={self.id!r}, title={self.title!r}, type={self.type!r})\"\n</code></pre>"},{"location":"reference/#kapipy.gis.base_item.BaseItem.__str__","title":"<code>__str__()</code>","text":"<p>Returns a user-friendly string representation of the BaseItem instance.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>User-friendly string representation.</p> Source code in <code>src\\kapipy\\gis\\base_item.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Returns a user-friendly string representation of the BaseItem instance.\n\n    Returns:\n        str: User-friendly string representation.\n    \"\"\"\n    return f\"{self.title or 'Unnamed Item'} (ID: {self.id}, Type: {self.type})\"\n</code></pre>"},{"location":"reference/#kapipy.features.table_item.TableItem.export_formats","title":"<code>export_formats</code>  <code>property</code>","text":"<p>Returns the export formats available for the item.</p> <p>Returns:</p> Type Description <code>list</code> <p>list or None: A list of export formats associated with the item, or None if not available.</p>"},{"location":"reference/#kapipy.features.table_item.TableItem.feature_count","title":"<code>feature_count</code>  <code>property</code>","text":"<p>Returns the number of features in the item.</p> <p>Returns:</p> Type Description <code>int | None</code> <p>int or None: The number of features associated with the item, or None if not available.</p>"},{"location":"reference/#kapipy.features.table_item.TableItem.fields","title":"<code>fields</code>  <code>property</code>","text":"<p>Returns the fields of the item.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of fields associated with the item.</p>"},{"location":"reference/#kapipy.features.table_item.TableItem.primary_key_fields","title":"<code>primary_key_fields</code>  <code>property</code>","text":"<p>Returns the primary key fields of the item.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of primary key fields associated with the item.</p>"},{"location":"reference/#kapipy.features.table_item.TableItem.services","title":"<code>services</code>  <code>property</code>","text":"<p>Returns the services associated with the item.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of services associated with the item.</p>"},{"location":"reference/#kapipy.features.table_item.TableItem.supports_changesets","title":"<code>supports_changesets</code>  <code>property</code>","text":"<p>Returns whether the item supports changesets.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the item supports changesets, False otherwise.</p>"},{"location":"reference/#kapipy.features.table_item.TableItem.__init__","title":"<code>__init__(gis, item_dict)</code>","text":"<p>Initializes the TableItem with a dictionary of item details.</p> <p>Parameters:</p> Name Type Description Default <code>gis</code> <code>GIS</code> <p>The GIS instance this item belongs to.</p> required <code>item_dict</code> <code>dict</code> <p>A dictionary containing the item's details, typically from an API response.</p> required Source code in <code>src\\kapipy\\features\\table_item.py</code> <pre><code>def __init__(self, gis: \"GIS\", item_dict: dict) -&gt; None:\n    \"\"\"\n    Initializes the TableItem with a dictionary of item details.\n\n    Parameters:\n        gis (GIS): The GIS instance this item belongs to.\n        item_dict (dict): A dictionary containing the item's details, typically from an API response.\n    \"\"\"\n\n    super().__init__(gis, item_dict)\n    self._supports_changesets = None\n    self._services = None\n    logger.debug(f\"Initializing KTableItem with id: {self.id}, title: {self.title}\")\n</code></pre>"},{"location":"reference/#kapipy.features.table_item.TableItem.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns an unambiguous string representation of the TableItem instance.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of the TableItem.</p> Source code in <code>src\\kapipy\\features\\table_item.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Returns an unambiguous string representation of the TableItem instance.\n\n    Returns:\n        str: String representation of the TableItem.\n    \"\"\"\n    return f\"TableItem(id={self.id}, title={self.title}, type={self.type}, kind={self.kind})\"\n</code></pre>"},{"location":"reference/#kapipy.features.table_item.TableItem.__str__","title":"<code>__str__()</code>","text":"<p>Returns a user-friendly string representation of the TableItem instance.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>User-friendly string representation.</p> Source code in <code>src\\kapipy\\features\\table_item.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Returns a user-friendly string representation of the TableItem instance.\n\n    Returns:\n        str: User-friendly string representation.\n    \"\"\"\n    return f\"{self.title or 'Unnamed Table'} (ID: {self.id}, Type: {self.type})\"\n</code></pre>"},{"location":"reference/#kapipy.features.table_item.TableItem.export","title":"<code>export(export_format, poll_interval=10, timeout=600, **kwargs)</code>","text":"<p>Exports the item in the specified format.</p> <p>Parameters:</p> Name Type Description Default <code>export_format</code> <code>str</code> <p>The format to export the item in.</p> required <code>poll_interval</code> <code>int</code> <p>The interval in seconds to poll the export job status. Default is 10 seconds.</p> <code>10</code> <code>timeout</code> <code>int</code> <p>The maximum time in seconds to wait for the export job to complete. Default is 600 seconds (10 minutes).</p> <code>600</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters for the export request.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>JobResult</code> <code>JobResult</code> <p>A JobResult instance containing the export job details.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If export validation fails.</p> Source code in <code>src\\kapipy\\features\\table_item.py</code> <pre><code>def export(\n    self,\n    export_format: str,\n    poll_interval: int = 10,\n    timeout: int = 600,\n    **kwargs: Any,\n) -&gt; JobResult:\n    \"\"\"\n    Exports the item in the specified format.\n\n    Parameters:\n        export_format (str): The format to export the item in.\n        poll_interval (int, optional): The interval in seconds to poll the export job status. Default is 10 seconds.\n        timeout (int, optional): The maximum time in seconds to wait for the export job to complete. Default is 600 seconds (10 minutes).\n        **kwargs: Additional parameters for the export request.\n\n    Returns:\n        JobResult: A JobResult instance containing the export job details.\n\n    Raises:\n        ValueError: If export validation fails.\n    \"\"\"\n\n    logger.debug(f\"Exporting item with id: {self.id} in format: {export_format}\")\n\n    export_format = self._resolve_export_format(export_format)\n\n    validate_export_request = self.validate_export_request(\n        export_format,\n        **kwargs,\n    )\n\n    if not validate_export_request:\n        logger.error(\n            f\"Export validation failed for item with id: {self.id} in format: {export_format}\"\n        )\n        raise ValueError(\n            f\"Export validation failed for item with id: {self.id} in format: {export_format}\"\n        )\n\n    export_request = export_features.request_export(\n        self._gis._api_url,\n        self._gis._api_key,\n        self.id,\n        self.type,\n        self.kind,\n        export_format,\n        **kwargs,\n    )\n\n    job_result = JobResult(\n        export_request, self._gis, poll_interval=poll_interval, timeout=timeout\n    )\n    self._jobs.append(job_result)\n    logger.info(\n        f\"Export job created for item with id: {self.id}, job id: {job_result.id}\"\n    )\n    return job_result\n</code></pre>"},{"location":"reference/#kapipy.features.table_item.TableItem.get_changeset","title":"<code>get_changeset(from_time, to_time=None, cql_filter=None, **kwargs)</code>","text":"<p>Retrieves a changeset for the item and returns it as a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>from_time</code> <code>str</code> <p>The start time for the changeset query, ISO format (e.g., \"2015-05-15T04:25:25.334974\").</p> required <code>to_time</code> <code>str</code> <p>The end time for the changeset query, ISO format. If not provided, the current time is used.</p> <code>None</code> <code>cql_filter</code> <code>str</code> <p>The CQL filter to apply to the changeset query.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters for the WFS query.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>pandas.DataFrame: The changeset data as a DataFrame.</p> Source code in <code>src\\kapipy\\features\\table_item.py</code> <pre><code>def get_changeset(\n    self, from_time: str, to_time: str = None, cql_filter: str = None, **kwargs: Any\n) -&gt; dict:\n    \"\"\"\n    Retrieves a changeset for the item and returns it as a DataFrame.\n\n    Parameters:\n        from_time (str): The start time for the changeset query, ISO format (e.g., \"2015-05-15T04:25:25.334974\").\n        to_time (str, optional): The end time for the changeset query, ISO format. If not provided, the current time is used.\n        cql_filter (str, optional): The CQL filter to apply to the changeset query.\n        **kwargs: Additional parameters for the WFS query.\n\n    Returns:\n        pandas.DataFrame: The changeset data as a DataFrame.\n    \"\"\"\n\n    result = self.get_changeset_json(\n        from_time=from_time, to_time=to_time, cql_filter=cql_filter, **kwargs\n    )\n\n    df = json_to_df(result, fields=self.fields)\n    return df\n</code></pre>"},{"location":"reference/#kapipy.features.table_item.TableItem.get_changeset_json","title":"<code>get_changeset_json(from_time, to_time=None, cql_filter=None, **kwargs)</code>","text":"<p>Retrieves a changeset for the item in JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>from_time</code> <code>str</code> <p>The start time for the changeset query, ISO format (e.g., \"2015-05-15T04:25:25.334974\").</p> required <code>to_time</code> <code>str</code> <p>The end time for the changeset query, ISO format. If not provided, the current time is used.</p> <code>None</code> <code>cql_filter</code> <code>str</code> <p>The CQL filter to apply to the changeset query.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters for the WFS query.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The changeset data in JSON format.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the item does not support changesets.</p> Source code in <code>src\\kapipy\\features\\table_item.py</code> <pre><code>def get_changeset_json(\n    self, from_time: str, to_time: str = None, cql_filter: str = None, **kwargs: Any\n) -&gt; dict:\n    \"\"\"\n    Retrieves a changeset for the item in JSON format.\n\n    Parameters:\n        from_time (str): The start time for the changeset query, ISO format (e.g., \"2015-05-15T04:25:25.334974\").\n        to_time (str, optional): The end time for the changeset query, ISO format. If not provided, the current time is used.\n        cql_filter (str, optional): The CQL filter to apply to the changeset query.\n        **kwargs: Additional parameters for the WFS query.\n\n    Returns:\n        dict: The changeset data in JSON format.\n\n    Raises:\n        ValueError: If the item does not support changesets.\n    \"\"\"\n\n    if not self.supports_changesets:\n        logger.error(f\"Item with id: {self.id} does not support changesets.\")\n        raise ValueError(\"This item does not support changesets.\")\n\n    if to_time is None:\n        to_time = datetime.now().isoformat()\n    logger.debug(\n        f\"Fetching changeset for item with id: {self.id} from {from_time} to {to_time}\"\n    )\n\n    viewparams = f\"from:{from_time};to:{to_time}\"\n\n    result = wfs_features.download_wfs_data(\n        url=self._wfs_url,\n        api_key=self._gis._api_key,\n        typeNames=f\"{self.type}-{self.id}-changeset\",\n        viewparams=viewparams,\n        cql_filter=cql_filter,\n        **kwargs,\n    )\n\n    return result\n</code></pre>"},{"location":"reference/#kapipy.features.table_item.TableItem.get_wfs_service","title":"<code>get_wfs_service()</code>","text":"<p>Returns a string that is the URL for the WFS service.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The URL for the WFS service.</p> Source code in <code>src\\kapipy\\features\\table_item.py</code> <pre><code>def get_wfs_service(self) -&gt; str:\n    \"\"\"\n    Returns a string that is the URL for the WFS service.\n\n    Returns:\n        str: The URL for the WFS service.\n    \"\"\"\n\n    logger.debug(f\"Creating WFS service for item with id: {self.id}\")\n    wfs_service = self._gis.wfs.operations\n</code></pre>"},{"location":"reference/#kapipy.features.table_item.TableItem.query","title":"<code>query(cql_filter=None, **kwargs)</code>","text":"<p>Executes a WFS query on the item and returns the result as a DataFrame.</p> <p>Parameters:</p> Name Type Description Default <code>cql_filter</code> <code>str</code> <p>The CQL filter to apply to the query.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters for the WFS query.</p> <code>{}</code> <p>Returns:</p> Type Description <code>dict</code> <p>pandas.DataFrame: The result of the WFS query as a DataFrame.</p> Source code in <code>src\\kapipy\\features\\table_item.py</code> <pre><code>def query(self, cql_filter: str = None, **kwargs: Any) -&gt; dict:\n    \"\"\"\n    Executes a WFS query on the item and returns the result as a DataFrame.\n\n    Parameters:\n        cql_filter (str, optional): The CQL filter to apply to the query.\n        **kwargs: Additional parameters for the WFS query.\n\n    Returns:\n        pandas.DataFrame: The result of the WFS query as a DataFrame.\n    \"\"\"\n    logger.debug(f\"Executing WFS query for item with id: {self.id}\")\n\n    result = self.query_json(cql_filter=cql_filter, **kwargs)\n\n    df = json_to_df(result, fields=self.fields)\n    return df\n</code></pre>"},{"location":"reference/#kapipy.features.table_item.TableItem.query_json","title":"<code>query_json(cql_filter=None, **kwargs)</code>","text":"<p>Executes a WFS query on the item and returns the result as JSON.</p> <p>Parameters:</p> Name Type Description Default <code>cql_filter</code> <code>str</code> <p>The CQL filter to apply to the query.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters for the WFS query.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The result of the WFS query in JSON format.</p> Source code in <code>src\\kapipy\\features\\table_item.py</code> <pre><code>def query_json(self, cql_filter: str = None, **kwargs: Any) -&gt; dict:\n    \"\"\"\n    Executes a WFS query on the item and returns the result as JSON.\n\n    Parameters:\n        cql_filter (str, optional): The CQL filter to apply to the query.\n        **kwargs: Additional parameters for the WFS query.\n\n    Returns:\n        dict: The result of the WFS query in JSON format.\n    \"\"\"\n    logger.debug(f\"Executing WFS query for item with id: {self.id}\")\n\n    result = wfs_features.download_wfs_data(\n        url=self._wfs_url,\n        api_key=self._gis._api_key,\n        typeNames=f\"{self.type}-{self.id}\",\n        cql_filter=cql_filter,\n        **kwargs,\n    )\n\n    return result\n</code></pre>"},{"location":"reference/#kapipy.features.table_item.TableItem.reset","title":"<code>reset()</code>","text":"<p>Resets the TableItem instance, clearing cached properties. This is useful for refreshing the item state.</p> Source code in <code>src\\kapipy\\features\\table_item.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"\n    Resets the TableItem instance, clearing cached properties.\n    This is useful for refreshing the item state.\n    \"\"\"\n\n    logger.info(f\"Resetting KTableItem with id: {self.id}\")\n    self._supports_changesets = None\n    self._services = None\n    self._raw_json = None\n</code></pre>"},{"location":"reference/#kapipy.features.table_item.TableItem.validate_export_request","title":"<code>validate_export_request(export_format, **kwargs)</code>","text":"<p>Validates the export request parameters for the item.</p> <p>Parameters:</p> Name Type Description Default <code>export_format</code> <code>str</code> <p>The format to export the item in.</p> required <code>**kwargs</code> <code>Any</code> <p>Additional parameters for the export request.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the export request is valid, False otherwise.</p> Source code in <code>src\\kapipy\\features\\table_item.py</code> <pre><code>def validate_export_request(\n    self,\n    export_format: str,\n    **kwargs: Any,\n) -&gt; bool:\n    \"\"\"\n    Validates the export request parameters for the item.\n\n    Parameters:\n        export_format (str): The format to export the item in.\n        **kwargs: Additional parameters for the export request.\n\n    Returns:\n        bool: True if the export request is valid, False otherwise.\n    \"\"\"\n\n    export_format = self._resolve_export_format(export_format)\n\n    # log out all the input parameters including kwargs\n    logger.info(\n        f\"Validating export request for item with id: {self.id}, {export_format=}, {kwargs=}\"\n    )\n\n    return export_features.validate_export_params(\n        self._gis._api_url,\n        self._gis._api_key,\n        self.id,\n        self.type,\n        self.kind,\n        export_format,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/#kapipy.features.vector_item.VectorItem.epsg","title":"<code>epsg</code>  <code>property</code>","text":"<p>Returns the EPSG code of the item.</p> <p>Returns:</p> Type Description <code>int | None</code> <p>int or None: The EPSG code associated with the item, or None if not available.</p>"},{"location":"reference/#kapipy.features.vector_item.VectorItem.export_formats","title":"<code>export_formats</code>  <code>property</code>","text":"<p>Returns the export formats available for the item.</p> <p>Returns:</p> Type Description <code>list | None</code> <p>list or None: A list of export formats associated with the item, or None if not available.</p>"},{"location":"reference/#kapipy.features.vector_item.VectorItem.extent","title":"<code>extent</code>  <code>property</code>","text":"<p>Returns the extent of the item.</p> <p>Returns:</p> Type Description <code>dict | None</code> <p>dict or None: A dictionary containing the extent of the item, or None if not available.</p>"},{"location":"reference/#kapipy.features.vector_item.VectorItem.feature_count","title":"<code>feature_count</code>  <code>property</code>","text":"<p>Returns the number of features in the item.</p> <p>Returns:</p> Type Description <code>int | None</code> <p>int or None: The number of features associated with the item, or None if not available.</p>"},{"location":"reference/#kapipy.features.vector_item.VectorItem.fields","title":"<code>fields</code>  <code>property</code>","text":"<p>Returns the fields of the item.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of fields associated with the item.</p>"},{"location":"reference/#kapipy.features.vector_item.VectorItem.geometry_type","title":"<code>geometry_type</code>  <code>property</code>","text":"<p>Returns the geometry type of the item.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>str or None: The geometry type associated with the item, or None if not available.</p>"},{"location":"reference/#kapipy.features.vector_item.VectorItem.primary_key_fields","title":"<code>primary_key_fields</code>  <code>property</code>","text":"<p>Returns the primary key fields of the item.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of primary key fields associated with the item.</p>"},{"location":"reference/#kapipy.features.vector_item.VectorItem.services","title":"<code>services</code>  <code>property</code>","text":"<p>Returns the services associated with the item.</p> <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of services associated with the item.</p>"},{"location":"reference/#kapipy.features.vector_item.VectorItem.supports_changesets","title":"<code>supports_changesets</code>  <code>property</code>","text":"<p>Returns whether the item supports changesets.</p> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the item supports changesets, False otherwise.</p>"},{"location":"reference/#kapipy.features.vector_item.VectorItem.__init__","title":"<code>__init__(gis, item_dict)</code>","text":"<p>Initializes the VectorItem with a dictionary of item details.</p> <p>Parameters:</p> Name Type Description Default <code>gis</code> <code>GIS</code> <p>The GIS instance this item belongs to.</p> required <code>item_dict</code> <code>dict</code> <p>A dictionary containing the item's details, typically from an API response.</p> required Source code in <code>src\\kapipy\\features\\vector_item.py</code> <pre><code>def __init__(self, gis: \"GIS\", item_dict: dict) -&gt; None:\n    \"\"\"\n    Initializes the VectorItem with a dictionary of item details.\n\n    Parameters:\n        gis (GIS): The GIS instance this item belongs to.\n        item_dict (dict): A dictionary containing the item's details, typically from an API response.\n    \"\"\"\n\n    super().__init__(gis, item_dict)\n    self._supports_changesets = None\n    self._services = None\n    logger.debug(\n        f\"Initializing KVectorItem with id: {self.id}, title: {self.title}\"\n    )\n</code></pre>"},{"location":"reference/#kapipy.features.vector_item.VectorItem.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns an unambiguous string representation of the VectorItem instance.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of the VectorItem.</p> Source code in <code>src\\kapipy\\features\\vector_item.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Returns an unambiguous string representation of the VectorItem instance.\n\n    Returns:\n        str: String representation of the VectorItem.\n    \"\"\"\n    return f\"VectorItem(id={self.id}, title={self.title}, type={self.type}, kind={self.kind})\"\n</code></pre>"},{"location":"reference/#kapipy.features.vector_item.VectorItem.__str__","title":"<code>__str__()</code>","text":"<p>Returns a user-friendly string representation of the VectorItem instance.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>User-friendly string representation.</p> Source code in <code>src\\kapipy\\features\\vector_item.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Returns a user-friendly string representation of the VectorItem instance.\n\n    Returns:\n        str: User-friendly string representation.\n    \"\"\"\n    return f\"{self.title or 'Unnamed Vector'} (ID: {self.id}, Type: {self.type})\"\n</code></pre>"},{"location":"reference/#kapipy.features.vector_item.VectorItem.changeset","title":"<code>changeset(from_time, to_time=None, wkid=None, cql_filter=None, bbox=None, output_format=None, **kwargs)</code>","text":"<p>Retrieves a changeset for the item and returns it as a GeoDataFrame, SEDF, or JSON.</p> <p>Parameters:</p> Name Type Description Default <code>from_time</code> <code>str</code> <p>The start time for the changeset query, ISO format (e.g., \"2015-05-15T04:25:25.334974\").</p> required <code>to_time</code> <code>str</code> <p>The end time for the changeset query, ISO format. If not provided, the current time is used.</p> <code>None</code> <code>wkid</code> <code>int</code> <p>The spatial reference system code to use for the query.</p> <code>None</code> <code>cql_filter</code> <code>str</code> <p>The CQL filter to apply to the changeset query.</p> <code>None</code> <code>bbox</code> <code>str or GeoDataFrame or DataFrame</code> <p>The bounding box to apply to the changeset query. If a GeoDataFrame or SEDF is provided, it will be converted to a bounding box string in WGS84.</p> <code>None</code> <code>output_format</code> <code>str</code> <p>The output format: 'gdf', 'sdf', or 'json'. Defaults to the best available.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters for the WFS query.</p> <code>{}</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>gpd.GeoDataFrame or arcgis.features.GeoAccessor or dict: The changeset data as a GeoDataFrame, SEDF, or JSON.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If the requested output format requires a package that is not installed.</p> <code>ValueError</code> <p>If the output format is unknown.</p> Source code in <code>src\\kapipy\\features\\vector_item.py</code> <pre><code>def changeset(\n    self,\n    from_time: str,\n    to_time: str = None,\n    wkid: int = None,\n    cql_filter: str = None,\n    bbox: Union[str, \"gpd.GeoDataFrame\", \"pd.DataFrame\"] = None,\n    output_format = None,\n    **kwargs: Any,\n) -&gt; \"gpd.GeoDataFrame\":\n    \"\"\"\n    Retrieves a changeset for the item and returns it as a GeoDataFrame, SEDF, or JSON.\n\n    Parameters:\n        from_time (str): The start time for the changeset query, ISO format (e.g., \"2015-05-15T04:25:25.334974\").\n        to_time (str, optional): The end time for the changeset query, ISO format. If not provided, the current time is used.\n        wkid (int, optional): The spatial reference system code to use for the query.\n        cql_filter (str, optional): The CQL filter to apply to the changeset query.\n        bbox (str or gpd.GeoDataFrame or pd.DataFrame, optional): The bounding box to apply to the changeset query.\n            If a GeoDataFrame or SEDF is provided, it will be converted to a bounding box string in WGS84.\n        output_format (str, optional): The output format: 'gdf', 'sdf', or 'json'. Defaults to the best available.\n        **kwargs: Additional parameters for the WFS query.\n\n    Returns:\n        gpd.GeoDataFrame or arcgis.features.GeoAccessor or dict: The changeset data as a GeoDataFrame, SEDF, or JSON.\n\n    Raises:\n        ImportError: If the requested output format requires a package that is not installed.\n        ValueError: If the output format is unknown.\n    \"\"\"\n\n    wkid = wkid if wkid is not None else self.epsg\n\n    if output_format is None:\n        output_format = get_default_output_format()\n    output_format = output_format.lower()\n    if output_format not in ('sdf', 'gdf', 'geodataframe', 'json', 'geojson'):\n        raise ValueError(f'Unknown output format: {output_format}')\n\n    result = self.changeset_to_json(\n        from_time=from_time,\n        to_time=to_time,\n        wkid=wkid,\n        cql_filter=cql_filter,\n        bbox=bbox,\n        **kwargs,\n    )\n\n    if output_format == 'sdf':\n        return geojson_to_sdf(result, wkid=wkid, fields=self.fields)\n    elif output_format in ('gdf', 'geodataframe'):\n        return geojson_to_gdf(result, wkid=wkid, fields=self.fields)\n    return result\n</code></pre>"},{"location":"reference/#kapipy.features.vector_item.VectorItem.changeset_to_json","title":"<code>changeset_to_json(from_time, to_time=None, wkid=None, cql_filter=None, bbox=None, **kwargs)</code>","text":"<p>Retrieves a changeset for the item in JSON format.</p> <p>Parameters:</p> Name Type Description Default <code>from_time</code> <code>str</code> <p>The start time for the changeset query, ISO format (e.g., \"2015-05-15T04:25:25.334974\").</p> required <code>to_time</code> <code>str</code> <p>The end time for the changeset query, ISO format. If not provided, the current time is used.</p> <code>None</code> <code>cql_filter</code> <code>str</code> <p>The CQL filter to apply to the changeset query.</p> <code>None</code> <code>bbox</code> <code>str or GeoDataFrame</code> <p>The bounding box to apply to the changeset query. If a GeoDataFrame is provided, it will be converted to a bounding box string in WGS84.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters for the WFS query.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The changeset data in JSON format.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the item does not support changesets.</p> Source code in <code>src\\kapipy\\features\\vector_item.py</code> <pre><code>def changeset_to_json(\n    self,\n    from_time: str,\n    to_time: str = None,\n    wkid = None,\n    cql_filter: str = None,\n    bbox: Union[str, \"gpd.GeoDataFrame\", \"pd.DataFrame\"] = None,\n    **kwargs: Any,\n) -&gt; dict:\n    \"\"\"\n    Retrieves a changeset for the item in JSON format.\n\n    Parameters:\n        from_time (str): The start time for the changeset query, ISO format (e.g., \"2015-05-15T04:25:25.334974\").\n        to_time (str, optional): The end time for the changeset query, ISO format. If not provided, the current time is used.\n        cql_filter (str, optional): The CQL filter to apply to the changeset query.\n        bbox (str or gpd.GeoDataFrame, optional): The bounding box to apply to the changeset query.\n            If a GeoDataFrame is provided, it will be converted to a bounding box string in WGS84.\n        **kwargs: Additional parameters for the WFS query.\n\n    Returns:\n        dict: The changeset data in JSON format.\n\n    Raises:\n        ValueError: If the item does not support changesets.\n    \"\"\"\n\n    if not self.supports_changesets:\n        logger.error(f\"Item with id: {self.id} does not support changesets.\")\n        raise ValueError(\"This item does not support changesets.\")\n\n    if to_time is None:\n        to_time = datetime.now().isoformat()\n    logger.debug(\n        f\"Fetching changeset for item with id: {self.id} from {from_time} to {to_time}\"\n    )\n\n    viewparams = f\"from:{from_time};to:{to_time}\"\n\n    # Handle bbox\n    if bbox is not None and not isinstance(bbox, str):              \n        bbox = sdf_or_gdf_to_bbox(bbox)\n\n    result = wfs_features.download_wfs_data(\n        url=self._wfs_url,\n        api_key=self._gis._api_key,\n        typeNames=f\"layer-{self.id}-changeset\",\n        viewparams=viewparams,\n        cql_filter=cql_filter,\n        srsName=f'EPSG:{wkid}' or f\"EPSG:{self.epsg}\" if self.epsg else None,\n        bbox=bbox,\n        **kwargs,\n    )\n    return result\n</code></pre>"},{"location":"reference/#kapipy.features.vector_item.VectorItem.export","title":"<code>export(export_format, wkid=None, extent=None, poll_interval=10, timeout=600, **kwargs)</code>","text":"<p>Exports the item in the specified format.</p> <p>Parameters:</p> Name Type Description Default <code>export_format</code> <code>str</code> <p>The format to export the item in.</p> required <code>wkid</code> <code>int</code> <p>The coordinate reference system code to use for the export.</p> <code>None</code> <code>extent</code> <code>dict or GeoDataFrame or DataFrame</code> <p>The extent to use for the export. Should be a GeoJSON dictionary, GeoDataFrame, or SEDF.</p> <code>None</code> <code>poll_interval</code> <code>int</code> <p>The interval in seconds to poll the export job status. Default is 10 seconds.</p> <code>10</code> <code>timeout</code> <code>int</code> <p>The maximum time in seconds to wait for the export job to complete. Default is 600 seconds (10 minutes).</p> <code>600</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters for the export request.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>JobResult</code> <code>JobResult</code> <p>A JobResult instance containing the export job details.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If export validation fails.</p> Source code in <code>src\\kapipy\\features\\vector_item.py</code> <pre><code>def export(\n    self,\n    export_format: str,\n    wkid: int = None,\n    extent: Union[dict, \"gpd.GeoDataFrame\", \"pd.DataFrame\"] = None,\n    poll_interval: int = 10,\n    timeout: int = 600,\n    **kwargs: Any,\n) -&gt; JobResult:\n    \"\"\"\n    Exports the item in the specified format.\n\n    Parameters:\n        export_format (str): The format to export the item in.\n        wkid (int, optional): The coordinate reference system code to use for the export.\n        extent (dict or gpd.GeoDataFrame or pd.DataFrame, optional): The extent to use for the export. Should be a GeoJSON dictionary, GeoDataFrame, or SEDF.\n        poll_interval (int, optional): The interval in seconds to poll the export job status. Default is 10 seconds.\n        timeout (int, optional): The maximum time in seconds to wait for the export job to complete. Default is 600 seconds (10 minutes).\n        **kwargs: Additional parameters for the export request.\n\n    Returns:\n        JobResult: A JobResult instance containing the export job details.\n\n    Raises:\n        ValueError: If export validation fails.\n    \"\"\"\n\n    logger.debug(f\"Exporting item with id: {self.id} in format: {export_format}\")\n\n    wkid = wkid if wkid is not None else self.epsg\n    crs = f'EPSG:{wkid}'\n\n    if extent is not None:\n        extent = sdf_or_gdf_to_single_polygon_geojson(extent)\n\n    export_format = self._resolve_export_format(export_format)\n\n    validate_export_request = self._validate_export_request(\n        export_format,\n        crs=crs,\n        extent=extent,\n        **kwargs,\n    )\n\n    if not validate_export_request:\n        logger.error(\n            f\"Export validation failed for item with id: {self.id} in format: {export_format}\"\n        )\n        raise ValueError(\n            f\"Export validation failed for item with id: {self.id} in format: {export_format}\"\n        )\n\n    export_request = export_features.request_export(\n        self._gis._api_url,\n        self._gis._api_key,\n        self.id,\n        self.type,\n        self.kind,\n        export_format,\n        crs=crs,\n        extent=extent,\n        **kwargs,\n    )\n\n    job_result = JobResult(\n        export_request, self._gis, poll_interval=poll_interval, timeout=timeout\n    )\n    self._jobs.append(job_result)\n    logger.debug(\n        f\"Export job created for item with id: {self.id}, job id: {job_result.id}\"\n    )\n    return job_result\n</code></pre>"},{"location":"reference/#kapipy.features.vector_item.VectorItem.get_wfs_service","title":"<code>get_wfs_service()</code>","text":"<p>Returns the item's WFS service URL.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The WFS service URL.</p> Source code in <code>src\\kapipy\\features\\vector_item.py</code> <pre><code>def get_wfs_service(self) -&gt; str:\n    \"\"\"\n    Returns the item's WFS service URL.\n\n    Returns:\n        str: The WFS service URL.\n    \"\"\"\n\n    logger.debug(f\"Creating WFS service for item with id: {self.id}\")\n    wfs_service = self._gis.wfs.operations\n</code></pre>"},{"location":"reference/#kapipy.features.vector_item.VectorItem.query","title":"<code>query(cql_filter=None, wkid=None, bbox=None, output_format=None, **kwargs)</code>","text":"<p>Executes a WFS query on the item and returns the result as a GeoDataFrame, SEDF, or JSON.</p> <p>Parameters:</p> Name Type Description Default <code>cql_filter</code> <code>str</code> <p>The CQL filter to apply to the query.</p> <code>None</code> <code>wkid</code> <code>int</code> <p>The spatial reference system code to use for the query.</p> <code>None</code> <code>bbox</code> <code>str or GeoDataFrame or DataFrame</code> <p>The bounding box to apply to the query. If a GeoDataFrame or SEDF is provided, it will be converted to a bounding box string in WGS84.</p> <code>None</code> <code>output_format</code> <code>str</code> <p>The output format: 'gdf', 'sdf', or 'json'. Defaults to the best available.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters for the WFS query.</p> <code>{}</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>gpd.GeoDataFrame or arcgis.features.GeoAccessor or dict: The result of the WFS query as a GeoDataFrame, SEDF, or JSON.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If the requested output format requires a package that is not installed.</p> <code>ValueError</code> <p>If the output format is unknown.</p> Source code in <code>src\\kapipy\\features\\vector_item.py</code> <pre><code>def query(\n    self,\n    cql_filter: str = None,\n    wkid: int = None,\n    bbox: Union[str, \"gpd.GeoDataFrame\", \"pd.DataFrame\"] = None,\n    output_format = None,\n    **kwargs: Any,\n) -&gt; \"gpd.GeoDataFrame\":\n    \"\"\"\n    Executes a WFS query on the item and returns the result as a GeoDataFrame, SEDF, or JSON.\n\n    Parameters:\n        cql_filter (str, optional): The CQL filter to apply to the query.\n        wkid (int, optional): The spatial reference system code to use for the query.\n        bbox (str or gpd.GeoDataFrame or pd.DataFrame, optional): The bounding box to apply to the query.\n            If a GeoDataFrame or SEDF is provided, it will be converted to a bounding box string in WGS84.\n        output_format (str, optional): The output format: 'gdf', 'sdf', or 'json'. Defaults to the best available.\n        **kwargs: Additional parameters for the WFS query.\n\n    Returns:\n        gpd.GeoDataFrame or arcgis.features.GeoAccessor or dict: The result of the WFS query as a GeoDataFrame, SEDF, or JSON.\n\n    Raises:\n        ImportError: If the requested output format requires a package that is not installed.\n        ValueError: If the output format is unknown.\n    \"\"\"\n\n    if output_format is None:\n        output_format = get_default_output_format()\n    output_format = output_format.lower()\n    if output_format not in ('sdf', 'gdf', 'geodataframe', 'json', 'geojson'):\n        raise ValueError(f'Unknown output format: {output_format}')\n\n    wkid = wkid if wkid is not None else self.epsg\n\n    result = self.query_to_json(\n        cql_filter=cql_filter,\n        wkid=wkid,\n        bbox=bbox,\n        **kwargs,\n    )\n\n    if output_format == 'sdf':\n        return geojson_to_sdf(result, wkid=wkid, fields=self.fields)\n    elif output_format in ('gdf', 'geodataframe'):\n        return geojson_to_gdf(result, wkid=wkid, fields=self.fields)\n    return result\n</code></pre>"},{"location":"reference/#kapipy.features.vector_item.VectorItem.query_to_json","title":"<code>query_to_json(cql_filter=None, wkid=None, bbox=None, **kwargs)</code>","text":"<p>Executes a WFS query on the item and returns the result as JSON.</p> <p>Parameters:</p> Name Type Description Default <code>cql_filter</code> <code>str</code> <p>The CQL filter to apply to the query.</p> <code>None</code> <code>wkid</code> <code>int</code> <p>The spatial reference system code to use for the query.</p> <code>None</code> <code>bbox</code> <code>str or GeoDataFrame or DataFrame</code> <p>The bounding box to apply to the query. If a GeoDataFrame or SEDF is provided, it will be converted to a bounding box string in WGS84.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters for the WFS query.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The result of the WFS query in JSON format.</p> Source code in <code>src\\kapipy\\features\\vector_item.py</code> <pre><code>def query_to_json(\n    self,\n    cql_filter: str = None,\n    wkid: int = None,\n    bbox: Union[str, \"gpd.GeoDataFrame\", \"pd.DataFrame\"] = None,\n    **kwargs: Any,\n) -&gt; dict:\n    \"\"\"\n    Executes a WFS query on the item and returns the result as JSON.\n\n    Parameters:\n        cql_filter (str, optional): The CQL filter to apply to the query.\n        wkid (int, optional): The spatial reference system code to use for the query.\n        bbox (str or gpd.GeoDataFrame or pd.DataFrame, optional): The bounding box to apply to the query.\n            If a GeoDataFrame or SEDF is provided, it will be converted to a bounding box string in WGS84.\n        **kwargs: Additional parameters for the WFS query.\n\n    Returns:\n        dict: The result of the WFS query in JSON format.\n    \"\"\"\n\n    logger.debug(f\"Executing WFS query for item with id: {self.id}\")\n\n    # Handle bbox\n    if bbox is not None and not isinstance(bbox, str):              \n        bbox = sdf_or_gdf_to_bbox(bbox)\n\n    result = wfs_features.download_wfs_data(\n        url=self._wfs_url,\n        api_key=self._gis._api_key,\n        typeNames=f\"{self.type}-{self.id}\",\n        cql_filter=cql_filter,\n        srsName=f'EPSG:{wkid}' or f\"EPSG:{self.epsg}\" if self.epsg else None,\n        bbox=bbox,\n        **kwargs,\n    )\n\n    return result\n</code></pre>"},{"location":"reference/#kapipy.features.vector_item.VectorItem.reset","title":"<code>reset()</code>","text":"<p>Resets the VectorItem instance, clearing cached properties. This is useful for refreshing the item state.</p> Source code in <code>src\\kapipy\\features\\vector_item.py</code> <pre><code>def reset(self) -&gt; None:\n    \"\"\"\n    Resets the VectorItem instance, clearing cached properties.\n    This is useful for refreshing the item state.\n    \"\"\"\n    logger.debug(f\"Resetting KVectorItem with id: {self.id}\")\n    self._supports_changesets = None\n    self._services = None\n    self._raw_json = None\n</code></pre>"},{"location":"reference/#kapipy.gis.content_manager.ContentManager.__init__","title":"<code>__init__(gis)</code>","text":"<p>Initializes the ContentManager with a GIS instance.</p> <p>Parameters:</p> Name Type Description Default <code>gis</code> <code>GIS</code> <p>The GIS instance to manage content for.</p> required Source code in <code>src\\kapipy\\gis\\content_manager.py</code> <pre><code>def __init__(self, gis: \"GIS\") -&gt; None:\n    \"\"\"\n    Initializes the ContentManager with a GIS instance.\n\n    Parameters:\n        gis (GIS): The GIS instance to manage content for.\n    \"\"\"\n    self._gis = gis\n</code></pre>"},{"location":"reference/#kapipy.gis.content_manager.ContentManager.__repr__","title":"<code>__repr__()</code>","text":"<p>Returns an unambiguous string representation of the ContentManager instance.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>String representation of the ContentManager.</p> Source code in <code>src\\kapipy\\gis\\content_manager.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Returns an unambiguous string representation of the ContentManager instance.\n\n    Returns:\n        str: String representation of the ContentManager.\n    \"\"\"\n    return f\"ContentManager(gis={repr(self._gis)})\"\n</code></pre>"},{"location":"reference/#kapipy.gis.content_manager.ContentManager.__str__","title":"<code>__str__()</code>","text":"<p>Returns a user-friendly string representation of the ContentManager instance.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>User-friendly string representation.</p> Source code in <code>src\\kapipy\\gis\\content_manager.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Returns a user-friendly string representation of the ContentManager instance.\n\n    Returns:\n        str: User-friendly string representation.\n    \"\"\"\n    return f\"ContentManager for GIS: {getattr(self._gis, 'name', None) or getattr(self._gis, 'url', 'Unknown')}\"\n</code></pre>"},{"location":"reference/#kapipy.gis.content_manager.ContentManager.download","title":"<code>download(jobs, folder, poll_interval=10)</code>","text":"<p>Downloads all exports from a list of jobs. Polls the jobs until they are finished. As soon as it encounters a finished job, it pauses polling and downloads that file, then resumes polling the remainder.</p> <p>Parameters:</p> Name Type Description Default <code>jobs</code> <code>list[JobResult]</code> <p>The list of job result objects to download.</p> required <code>folder</code> <code>str</code> <p>The output folder where files will be saved.</p> required <code>poll_interval</code> <code>int</code> <p>The interval in seconds to poll the jobs. Default is 10.</p> <code>10</code> <p>Returns:</p> Type Description <code>list[JobResults]</code> <p>list[JobResult]: The list of job result objects after download.</p> Source code in <code>src\\kapipy\\gis\\content_manager.py</code> <pre><code>def download(\n    self, jobs: list[\"JobResults\"], folder: str, poll_interval=10\n) -&gt; list[\"JobResults\"]:\n\n    \"\"\"\n    Downloads all exports from a list of jobs.\n    Polls the jobs until they are finished. As soon as it encounters a finished job,\n    it pauses polling and downloads that file, then resumes polling the remainder.\n\n    Parameters:\n        jobs (list[JobResult]): The list of job result objects to download.\n        folder (str): The output folder where files will be saved.\n        poll_interval (int, optional): The interval in seconds to poll the jobs. Default is 10.\n\n    Returns:\n        list[JobResult]: The list of job result objects after download.\n    \"\"\"\n\n    pending_jobs = list(jobs)\n\n    while pending_jobs:\n        logger.info(\"Polling export jobs...\")\n        time.sleep(poll_interval)\n\n        for job in pending_jobs[:]:  # iterate over a copy\n            state = job.state\n\n            if state != \"processing\":\n                job.download(folder=folder)\n                pending_jobs.remove(job)\n\n        logger.info(f\"{len(pending_jobs)} jobs remaining...\")\n\n    logger.info(\"All jobs completed and downloaded.\")\n    return jobs\n</code></pre>"},{"location":"reference/#kapipy.gis.content_manager.ContentManager.get","title":"<code>get(id)</code>","text":"<p>Retrieves and instantiates a content item by ID from the GIS.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>str</code> <p>The ID of the content to retrieve.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>VectorItem or TableItem or None: The instantiated item, depending on its kind, or None if not found.</p> <p>Raises:</p> Type Description <code>BadRequest</code> <p>If the content is not found or the request is invalid.</p> <code>UnknownItemTypeError</code> <p>If the item kind is not supported.</p> <code>ServerError</code> <p>If the item does not have a URL.</p> Source code in <code>src\\kapipy\\gis\\content_manager.py</code> <pre><code>def get(self, id: str) -&gt; dict:\n    \"\"\"\n    Retrieves and instantiates a content item by ID from the GIS.\n\n    Parameters:\n        id (str): The ID of the content to retrieve.\n\n    Returns:\n        VectorItem or TableItem or None: The instantiated item, depending on its kind, or None if not found.\n\n    Raises:\n        BadRequest: If the content is not found or the request is invalid.\n        UnknownItemTypeError: If the item kind is not supported.\n        ServerError: If the item does not have a URL.\n    \"\"\"\n\n    search_result = self._search_by_id(id)\n    if not search_result or \"error\" in search_result:\n        raise BadRequest(f\"Content with id {id} not found or invalid request.\")\n    if len(search_result) == 0:\n        return None\n    elif len(search_result) &gt; 1:\n        raise BadRequest(\n            f\"Multiple contents found for id {id}. Please refine your search.\"\n        )\n\n    # Assuming the first item is the desired content\n    item_json = search_result[0]\n    if \"url\" not in item_json:\n        raise ServerError(f\"Item with id {id} does not have a URL.\")\n    item_details = self._gis.get(item_json.get(\"url\"))\n\n    # Based on the kind of item, return the appropriate item class.\n    if item_details.get(\"kind\") == \"vector\":\n        from kapipy.features import VectorItem\n\n        item = VectorItem(self._gis, item_details)\n    elif item_details.get(\"kind\") == \"table\":\n        from kapipy.features import TableItem\n\n        item = TableItem(self._gis, item_details)\n    else:\n        raise UnknownItemTypeError(\n            f\"Unsupported item kind: {item_details.get('kind')}\"\n        )\n\n    return item\n</code></pre>"},{"location":"reference/#kapipy.gis.job_result.JobResult.created_at","title":"<code>created_at</code>  <code>property</code>","text":"<p>Returns the creation time of the job.</p> <p>Returns:</p> Type Description <code>str | None</code> <p>str | None: The creation timestamp, or None if not available.</p>"},{"location":"reference/#kapipy.gis.job_result.JobResult.name","title":"<code>name</code>  <code>property</code>","text":"<p>Returns the name of the job.</p>"},{"location":"reference/#kapipy.gis.job_result.JobResult.progress","title":"<code>progress</code>  <code>property</code>","text":"<p>Returns the progress of the job as a percentage.</p> <p>Returns:</p> Type Description <code>float | None</code> <p>float | None: The progress value, or None if not available.</p>"},{"location":"reference/#kapipy.gis.job_result.JobResult.state","title":"<code>state</code>  <code>property</code>","text":"<p>Returns the current state of the job.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The job state. Possible values include 'complete', 'processing', 'cancelled', 'error', 'gone'.</p>"},{"location":"reference/#kapipy.gis.job_result.JobResult.status","title":"<code>status</code>  <code>property</code>","text":"<p>Refreshes and returns the current job status.</p> <p>Returns:</p> Name Type Description <code>JobStatus</code> <code>JobStatus</code> <p>The state and progress of the job.</p>"},{"location":"reference/#kapipy.gis.job_result.JobResult.__init__","title":"<code>__init__(payload, gis, poll_interval=10, timeout=600)</code>","text":"<p>Initializes the JobResult instance.</p> <p>Parameters:</p> Name Type Description Default <code>payload</code> <code>dict</code> <p>The job payload, typically from an API response.</p> required <code>gis</code> <code>GIS</code> <p>The GIS instance associated with this job.</p> required <code>poll_interval</code> <code>int</code> <p>Interval in seconds to poll the job status. Default is 10.</p> <code>10</code> <code>timeout</code> <code>int</code> <p>Maximum time in seconds to wait for the job to complete. Default is 600.</p> <code>600</code> Source code in <code>src\\kapipy\\gis\\job_result.py</code> <pre><code>def __init__(\n    self,\n    payload: dict,\n    gis: \"GIS\",\n    poll_interval: int = 10,\n    timeout: int = 600,\n) -&gt; None:\n    \"\"\"\n    Initializes the JobResult instance.\n\n    Parameters:\n        payload (dict): The job payload, typically from an API response.\n        gis (GIS): The GIS instance associated with this job.\n        poll_interval (int, optional): Interval in seconds to poll the job status. Default is 10.\n        timeout (int, optional): Maximum time in seconds to wait for the job to complete. Default is 600.\n    \"\"\"\n\n    self._initial_payload = payload\n    self._job_url = payload[\"url\"]\n    self._id = payload[\"id\"]\n    self._poll_interval = poll_interval\n    self._timeout = timeout\n    self._last_response = payload\n    self._gis = gis\n</code></pre>"},{"location":"reference/#kapipy.gis.job_result.JobResult.__str__","title":"<code>__str__()</code>","text":"<p>Returns a user-friendly string representation of the JobResult.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>User-friendly string representation.</p> Source code in <code>src\\kapipy\\gis\\job_result.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Returns a user-friendly string representation of the JobResult.\n\n    Returns:\n        str: User-friendly string representation.\n    \"\"\"\n\n    self._refresh_sync()\n    return (\n        f\"JobResult(id={self.id}, name='{self.name}', \"\n        f\"status='{self._last_response.get('state')}', \"\n        f\"progress={self.progress})\"\n    )\n</code></pre>"},{"location":"reference/#kapipy.gis.job_result.JobResult.download","title":"<code>download(folder, file_name=None)</code>","text":"<p>Waits for the job to finish, then downloads the file synchronously.</p> <p>Parameters:</p> Name Type Description Default <code>folder</code> <code>str</code> <p>The folder where the file will be saved.</p> required <code>file_name</code> <code>str</code> <p>The name of the file to save. If None, uses the job name.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>DownloadResult</code> <code>DownloadResult</code> <p>Object containing details about the downloaded file.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the download URL is not available.</p> Source code in <code>src\\kapipy\\gis\\job_result.py</code> <pre><code>def download(self, folder: str, file_name: str | None = None) -&gt; DownloadResult:\n    \"\"\"\n    Waits for the job to finish, then downloads the file synchronously.\n\n    Parameters:\n        folder (str): The folder where the file will be saved.\n        file_name (str, optional): The name of the file to save. If None, uses the job name.\n\n    Returns:\n        DownloadResult: Object containing details about the downloaded file.\n\n    Raises:\n        ValueError: If the download URL is not available.\n    \"\"\"\n\n    self.output()  # ensure job is complete\n    if not self.download_url:\n        raise ValueError(\n            \"Download URL not available. Job may not have completed successfully.\"\n        )\n\n    file_name = f\"{file_name}.zip\" if file_name else f\"{self.name}.zip\"\n    file_path = os.path.join(folder, file_name)\n    if not os.path.exists(folder):\n        os.makedirs(folder, exist_ok=True)\n\n    headers = {\"Authorization\": f\"key {self._gis._api_key}\"}\n\n    with httpx.Client(follow_redirects=True) as client:\n        resp = client.get(self.download_url, headers=headers, follow_redirects=True)\n        resp.raise_for_status()\n        final_url = str(resp.url)\n\n        with client.stream(\"GET\", final_url) as r, open(file_path, \"wb\") as f:\n            r.raise_for_status()\n            for chunk in r.iter_bytes():\n                f.write(chunk)\n\n    file_size_bytes = os.path.getsize(file_path)\n    checksum = None\n    try:\n        with open(file_path, \"rb\") as f:\n            checksum = hashlib.sha256(f.read()).hexdigest()\n    except Exception:\n        pass\n    completed_at = time.time()\n\n    # Set as attributes on the JobResult instance\n    self.download_folder = folder\n    self.download_filename = file_name\n    self.download_file_path = file_path\n    self.download_file_size_bytes = file_size_bytes\n    self.download_completed_at = completed_at\n    self.download_resolved_url = final_url\n    self.download_checksum = checksum\n\n    return DownloadResult(\n        folder=folder,\n        filename=file_name,\n        file_path=file_path,\n        file_size_bytes=file_size_bytes,\n        download_url=self.download_url,\n        final_url=final_url,\n        job_id=self._id,\n        completed_at=completed_at,\n        checksum=checksum,\n    )\n</code></pre>"},{"location":"reference/#kapipy.gis.job_result.JobResult.output","title":"<code>output()</code>","text":"<p>Blocks until the job completes, then returns the final job response.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The final job response after completion.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If the job does not complete within the timeout.</p> <code>RuntimeError</code> <p>If the job fails or is cancelled.</p> Source code in <code>src\\kapipy\\gis\\job_result.py</code> <pre><code>def output(self) -&gt; dict:\n    \"\"\"\n    Blocks until the job completes, then returns the final job response.\n\n    Returns:\n        dict: The final job response after completion.\n\n    Raises:\n        TimeoutError: If the job does not complete within the timeout.\n        RuntimeError: If the job fails or is cancelled.\n    \"\"\"\n\n    start = time.time()\n\n    while True:            \n        state = self._last_response.get(\"state\")\n        if state != \"processing\":\n            break\n\n        if (time.time() - start) &gt; self._timeout:\n            raise TimeoutError(\n                f\"Export job {self._id} did not complete within timeout.\"\n            )\n\n        time.sleep(self._poll_interval)\n        self._refresh_sync()\n\n    if self._last_response.get(\"state\") != \"complete\":\n        raise RuntimeError(\n            f\"Export job {self._id} failed with state: {self._last_response.get('state')}\"\n        )\n\n    return self._last_response\n</code></pre>"},{"location":"reference/#kapipy.gis.job_result.JobResult.to_dict","title":"<code>to_dict()</code>","text":"<p>Returns the most recent job status response as a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The most recent job status response.</p> Source code in <code>src\\kapipy\\gis\\job_result.py</code> <pre><code>def to_dict(self) -&gt; dict:\n    \"\"\"\n    Returns the most recent job status response as a dictionary.\n\n    Returns:\n        dict: The most recent job status response.\n    \"\"\"\n    return self._last_response\n</code></pre>"},{"location":"reference/#feature-utilities","title":"Feature Utilities","text":"<p>The following are helper features used internally by the classes to interact with the Koordinates API and perform data conversions.</p> <p>custom_errors.py Custom exceptions.</p>"},{"location":"reference/#kapipy.features.conversion.geojson_to_featureset","title":"<code>geojson_to_featureset(geojson, fields, wkid=4326)</code>","text":"<p>Converts a GeoJSON FeatureCollection or list of features into an ArcGIS FeatureSet.</p> <p>Parameters:</p> Name Type Description Default <code>geojson</code> <code>dict or list</code> <p>A GeoJSON FeatureCollection (dict with 'features') or a list of GeoJSON features.</p> required <code>fields</code> <code>list</code> <p>A list of field definitions like [{'name': 'id', 'type': 'integer'}, ...].</p> required <code>wkid</code> <code>int</code> <p>The well-known ID of the spatial reference system (e.g., 2193 for NZTM).</p> <code>4326</code> <p>Returns:</p> Type Description <code>FeatureSet</code> <p>arcgis.features.FeatureSet: An ArcGIS-compatible FeatureSet.</p> Source code in <code>src\\kapipy\\features\\conversion.py</code> <pre><code>def geojson_to_featureset(geojson, fields, wkid=4326) -&gt; \"arcgis.features.FeatureSet\":\n    \"\"\"\n    Converts a GeoJSON FeatureCollection or list of features into an ArcGIS FeatureSet.\n\n    Args:\n        geojson (dict or list): A GeoJSON FeatureCollection (dict with 'features') or a list of GeoJSON features.\n        fields (list): A list of field definitions like [{'name': 'id', 'type': 'integer'}, ...].\n        wkid (int): The well-known ID of the spatial reference system (e.g., 2193 for NZTM).\n\n    Returns:\n        arcgis.features.FeatureSet: An ArcGIS-compatible FeatureSet.\n    \"\"\"\n\n    if not has_arcgis:\n        raise ImportError(\"arcgis is not installed.\")\n\n    from arcgis.features import FeatureSet, Feature\n    from arcgis.geometry import Geometry, SpatialReference\n    import pandas as pd\n\n    # Normalize input to a list of features\n    if isinstance(geojson, dict) and \"features\" in geojson:\n        features = geojson[\"features\"]\n    elif isinstance(geojson, list):\n        features = geojson\n    else:\n        raise ValueError(\"geojson must be a FeatureCollection or list of features.\")\n\n    arcgis_fields = [\n        {**f, \"type\": map_field_type(f[\"type\"])}\n        for f in fields\n        if f[\"type\"].lower() != \"geometry\"  # exclude geometry from field list\n    ]\n\n\n    # Infer geometry type from first feature\n    geojson_type = features[0].get(\"geometry\", {}).get(\"type\")\n    geometry_type_map = {\n        \"Point\": \"esriGeometryPoint\",\n        \"MultiPoint\": \"esriGeometryMultipoint\",\n        \"LineString\": \"esriGeometryPolyline\",\n        \"Polygon\": \"esriGeometryPolygon\",\n    }\n    geometry_type = geometry_type_map.get(geojson_type)\n    if not geometry_type:\n        raise ValueError(f\"Unsupported geometry type: {geojson_type}\")\n\n    # Convert features\n    arcgis_features = []\n    for feature in features:\n        geometry = feature.get(\"geometry\")\n        attributes = feature.get(\"properties\", {})\n\n        # ArcGIS expects the geometry dict to include spatial reference\n        arcgis_geometry = Geometry({\"spatialReference\": {\"wkid\": wkid}, **geometry})\n\n        arcgis_feature = Feature(geometry=arcgis_geometry, attributes=attributes)\n        arcgis_features.append(arcgis_feature)\n\n    # Construct FeatureSet\n    return FeatureSet(\n        features=arcgis_features,\n        fields=arcgis_fields,\n        geometry_type=geometry_type,\n        spatial_reference=SpatialReference(wkid),\n    )\n</code></pre>"},{"location":"reference/#kapipy.features.conversion.geojson_to_gdf","title":"<code>geojson_to_gdf(geojson, wkid, fields=None)</code>","text":"<p>Convert GeoJSON features to a GeoDataFrame with enforced data types.</p> <p>Parameters:</p> Name Type Description Default <code>geojson</code> <code>dict or list</code> <p>A GeoJSON FeatureCollection (dict) or a list of GeoJSON feature dicts.</p> required <code>wkid</code> <code>int</code> <p>The EPSG code for the coordinate reference system (e.g., 4326).</p> required <code>fields</code> <code>list[dict]</code> <p>A list of dictionaries specifying field names and their desired data types.</p> <code>None</code> <p>Returns:</p> Type Description <code>GeoDataFrame</code> <p>gpd.GeoDataFrame: A GeoDataFrame with the specified CRS and column types.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If geopandas is not installed.</p> <code>ValueError</code> <p>If the geojson input is invalid.</p> Source code in <code>src\\kapipy\\features\\conversion.py</code> <pre><code>def geojson_to_gdf(\n    geojson: dict[str, Any] | list[dict[str, Any]],\n    wkid: int,\n    fields: list[dict[str, str]] | None = None,\n) -&gt; \"gpd.GeoDataFrame\":\n    \"\"\"\n    Convert GeoJSON features to a GeoDataFrame with enforced data types.\n\n    Parameters:\n        geojson (dict or list): A GeoJSON FeatureCollection (dict) or a list of GeoJSON feature dicts.\n        wkid (int): The EPSG code for the coordinate reference system (e.g., 4326).\n        fields (list[dict], optional): A list of dictionaries specifying field names and their desired data types.\n\n    Returns:\n        gpd.GeoDataFrame: A GeoDataFrame with the specified CRS and column types.\n\n    Raises:\n        ImportError: If geopandas is not installed.\n        ValueError: If the geojson input is invalid.\n    \"\"\"\n\n    logger.debug(\"Converting GeoJSON to GeoDataFrame...\")\n    if not has_geopandas:\n        raise ImportError(\"geopandas is not installed.\")\n    import geopandas as gpd\n\n    # if the geosjon is None, return an empty GeoDataFrame\n    if geojson is None:\n        logger.warning(\"Received None as geojson input, returning empty GeoDataFrame.\")\n        return gpd.GeoDataFrame(columns=[], geometry=[])\n\n    # Extract features from a FeatureCollection if needed\n    if isinstance(geojson, dict) and geojson.get(\"type\") == \"FeatureCollection\":\n        features = geojson.get(\"features\", [])\n    elif isinstance(geojson, list):\n        features = geojson\n    else:\n        raise ValueError(\n            \"Invalid geojson input. Expected a FeatureCollection or list of features.\"\n        )\n\n    # Flatten properties and extract geometry\n    records = []\n    geometries = []\n    for feature in features:\n        props = feature.get(\"properties\", {})\n        geom = feature.get(\"geometry\")\n        records.append(props)\n        geometries.append(shape(geom) if geom else None)\n\n    # Create GeoDataFrame\n    crs = f\"EPSG:{wkid}\"\n    df = pd.DataFrame(records)\n    gdf = gpd.GeoDataFrame(df, geometry=geometries, crs=crs)\n\n    # Apply data type mapping\n    if fields and False:\n        for field in fields:\n            col = field.get(\"name\")\n            dtype = field.get(\"type\").lower()\n            if dtype == \"geometry\":\n                continue  # Skip geometry fields as they are already handled\n            if col in gdf.columns:\n                try:\n                    if dtype in [\"int\", \"bigint\", \"integer\", \"int32\", \"int64\"]:\n                        gdf[col] = (\n                            pd.to_numeric(gdf[col], errors=\"coerce\")\n                            .fillna(0)\n                            .astype(\"int32\")\n                        )\n                    elif dtype in [\"float\", \"double\"]:\n                        gdf[col] = pd.to_numeric(gdf[col], errors=\"coerce\")\n                    elif dtype in [\"str\", \"string\"]:\n                        gdf[col] = gdf[col].astype(str)\n                    elif dtype == \"bool\":\n                        gdf[col] = gdf[col].astype(bool)\n                    else:\n                        logger.warning(\n                            f\"Unsupported data type '{dtype}' for column '{col}'. Skipping conversion.\"\n                        )\n                except Exception as e:\n                    raise ValueError(\n                        f\"Failed to convert column '{col}' to {dtype}: {e}\"\n                    )\n    return gdf\n</code></pre>"},{"location":"reference/#kapipy.features.conversion.geojson_to_sdf","title":"<code>geojson_to_sdf(geojson, wkid, fields=None)</code>","text":"<p>Convert GeoJSON features to a Spatially Enabled DataFrame (SEDF) with enforced data types.</p> <p>Parameters:</p> Name Type Description Default <code>geojson</code> <code>dict or list</code> <p>A GeoJSON FeatureCollection (dict) or a list of GeoJSON feature dicts.</p> required <code>wkid</code> <code>int</code> <p>The EPSG code for the coordinate reference system (e.g., 4326).</p> required <code>fields</code> <code>list[dict]</code> <p>A list of dictionaries specifying field names and their desired data types.</p> <code>None</code> <p>Returns:</p> Type Description <code>GeoAccessor</code> <p>arcgis.features.GeoAccessor: A Spatially Enabled DataFrame with the specified CRS and column types.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If arcgis is not installed.</p> <code>ValueError</code> <p>If the geojson input is invalid.</p> Source code in <code>src\\kapipy\\features\\conversion.py</code> <pre><code>def geojson_to_sdf(\n    geojson: dict[str, Any] | list[dict[str, Any]],\n    wkid: int,\n    fields: list[dict[str, str]] | None = None,\n) -&gt; \"arcgis.features.GeoAccessor\":\n    \"\"\"\n    Convert GeoJSON features to a Spatially Enabled DataFrame (SEDF) with enforced data types.\n\n    Parameters:\n        geojson (dict or list): A GeoJSON FeatureCollection (dict) or a list of GeoJSON feature dicts.\n        wkid (int): The EPSG code for the coordinate reference system (e.g., 4326).\n        fields (list[dict], optional): A list of dictionaries specifying field names and their desired data types.\n\n    Returns:\n        arcgis.features.GeoAccessor: A Spatially Enabled DataFrame with the specified CRS and column types.\n\n    Raises:\n        ImportError: If arcgis is not installed.\n        ValueError: If the geojson input is invalid.\n    \"\"\"\n\n    # if the geojson is None, return an empty SEDF\n    if geojson is None:\n        logger.warning(\"Received None as geojson input, returning empty SEDF.\")\n        return pd.DataFrame()\n\n    if not has_arcgis:\n        raise ImportError(\"arcgis is not installed.\")\n\n    import pandas as pd\n    from arcgis.features import GeoAccessor, GeoSeriesAccessor\n    from arcgis.geometry import SpatialReference\n\n    logger.debug(f\"{wkid=}\")\n    feature_set = geojson_to_featureset(geojson=geojson, fields=fields, wkid=wkid)\n    sdf = feature_set.sdf\n\n    return sdf\n</code></pre>"},{"location":"reference/#kapipy.features.conversion.get_data_type","title":"<code>get_data_type(obj)</code>","text":"<p>Determines if the object is a string, a GeoDataFrame (gdf), or an ArcGIS SEDF (sdf).</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>Any</code> <p>The object to check.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>\"str\" if string, \"gdf\" if GeoDataFrame, \"sdf\" if ArcGIS SEDF, or \"unknown\" if none match.</p> Source code in <code>src\\kapipy\\features\\conversion.py</code> <pre><code>def get_data_type(obj: Any) -&gt; str:\n    \"\"\"\n    Determines if the object is a string, a GeoDataFrame (gdf), or an ArcGIS SEDF (sdf).\n\n    Parameters:\n        obj: The object to check.\n\n    Returns:\n        str: \"str\" if string, \"gdf\" if GeoDataFrame, \"sdf\" if ArcGIS SEDF, or \"unknown\" if none match.\n    \"\"\"\n\n    # Check for string\n    if isinstance(obj, str):\n        return \"str\"\n\n    # Check for GeoDataFrame\n    if has_geopandas:\n        try:\n            import geopandas as gpd\n\n            if isinstance(obj, gpd.GeoDataFrame):\n                return \"gdf\"\n        except ImportError:\n            pass\n\n    # Check for ArcGIS SEDF (Spatially Enabled DataFrame)\n    if has_arcgis:\n        try:\n            import pandas as pd\n            from arcgis.features import GeoAccessor\n\n            # SEDF is a pandas.DataFrame with a _spatial accessor\n            # pandas.core.frame.DataFrame\n            if isinstance(pd.DataFrame) and hasattr(obj, \"spatial\"):\n                return \"sdf\"\n        except ImportError:\n            pass\n\n    return \"unknown\"\n</code></pre>"},{"location":"reference/#kapipy.features.conversion.get_default_output_format","title":"<code>get_default_output_format()</code>","text":"<p>Return a default output format based on which packages are available.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>\"sdf\" if arcgis is installed, \"gdf\" if geopandas is installed, otherwise \"json\".</p> Source code in <code>src\\kapipy\\features\\conversion.py</code> <pre><code>def get_default_output_format() -&gt; str:\n    \"\"\"\n    Return a default output format based on which packages are available.\n\n    Returns:\n        str: \"sdf\" if arcgis is installed, \"gdf\" if geopandas is installed, otherwise \"json\".\n    \"\"\"\n\n    if has_arcgis:\n        return \"sdf\"\n    if has_geopandas:\n        return \"gdf\"\n    return \"json\"\n</code></pre>"},{"location":"reference/#kapipy.features.conversion.json_to_df","title":"<code>json_to_df(json, fields=None)</code>","text":"<p>Convert JSON features to a DataFrame with enforced data types.</p> Paramters <p>json (dict or list): A JSON FeatureCollection (dict) or a list of JSON feature dicts. fields (list[dict], optional): A list of dictionaries specifying field names and their desired data types.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame with the specified column types.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the json input is invalid.</p> Source code in <code>src\\kapipy\\features\\conversion.py</code> <pre><code>def json_to_df(\n    json: dict[str, Any] | list[dict[str, Any]],\n    fields: list[dict[str, str]] | None = None,\n) -&gt; pd.DataFrame:\n    \"\"\"\n    Convert JSON features to a DataFrame with enforced data types.\n\n    Paramters:\n        json (dict or list): A JSON FeatureCollection (dict) or a list of JSON feature dicts.\n        fields (list[dict], optional): A list of dictionaries specifying field names and their desired data types.\n\n    Returns:\n        pd.DataFrame: A DataFrame with the specified column types.\n\n    Raises:\n        ValueError: If the json input is invalid.\n    \"\"\"\n\n    logger.debug(\"Converting JSON to DataFrame...\")\n\n    # Extract features from a FeatureCollection if needed\n    if isinstance(json, dict) and json.get(\"type\") == \"FeatureCollection\":\n        features = json.get(\"features\", [])\n    elif isinstance(json, list):\n        features = json\n    else:\n        raise ValueError(\n            \"Invalid json input. Expected a FeatureCollection or list of features.\"\n        )\n\n    # Flatten properties and extract geometry\n    records = []\n    for feature in features:\n        props = feature.get(\"properties\", {})\n        records.append(props)\n    df = pd.DataFrame(records)\n\n    # Apply data type mapping\n    if fields and False:\n        for field in fields:\n            col = field.get(\"name\")\n            dtype = field.get(\"type\").lower()\n            if col in df.columns:\n                try:\n                    if dtype in [\"int\", \"bigint\", \"integer\", \"int32\", \"int64\"]:\n                        df[col] = (\n                            pd.to_numeric(df[col], errors=\"coerce\")\n                            .fillna(0)\n                            .astype(\"int32\")\n                        )\n                    elif dtype in [\"float\", \"double\"]:\n                        df[col] = pd.to_numeric(df[col], errors=\"coerce\")\n                    elif dtype in [\"str\", \"string\"]:\n                        df[col] = df[col].astype(str)\n                    elif dtype == \"bool\":\n                        df[col] = df[col].astype(bool)\n                    else:\n                        logger.warning(\n                            f\"Unsupported data type '{dtype}' for column '{col}'. Skipping conversion.\"\n                        )\n                except Exception as e:\n                    raise ValueError(\n                        f\"Failed to convert column '{col}' to {dtype}: {e}\"\n                    )\n\n    return df\n</code></pre>"},{"location":"reference/#kapipy.features.conversion.sdf_or_gdf_to_bbox","title":"<code>sdf_or_gdf_to_bbox(df)</code>","text":"<p>Convert a GeoDataFrame or SEDF to a bounding box string in EPSG:4326.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>GeoDataFrame or GeoAccessor</code> <p>A GeoDataFrame or SEDF.</p> required <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Bounding box string in the format \"minx,miny,maxx,maxy,EPSG:4326\".</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the DataFrame is empty or does not contain valid geometries.</p> Source code in <code>src\\kapipy\\features\\conversion.py</code> <pre><code>def sdf_or_gdf_to_bbox(df: Any) -&gt; str:\n    \"\"\"\n    Convert a GeoDataFrame or SEDF to a bounding box string in EPSG:4326.\n\n    Parameters:\n        df (gpd.GeoDataFrame or arcgis.features.GeoAccessor): A GeoDataFrame or SEDF.\n\n    Returns:\n        str: Bounding box string in the format \"minx,miny,maxx,maxy,EPSG:4326\".\n\n    Raises:\n        ValueError: If the DataFrame is empty or does not contain valid geometries.\n    \"\"\"\n\n    if df.empty:\n        raise ValueError(\"sdf or gdf must contain at least one geometry.\")\n\n    data_type = get_data_type(df)\n    if data_type == \"sdf\":\n        if not df.spatial.geometry_type in [\"polygon\", \"multipolygon\"]:\n            raise ValueError(\"sdf must contain polygon geometries.\")\n        if df.spatial.sr.wkid == 4326:\n            df.spatial.project({\"wkid\": 4326})\n        return \",\".join(map(str, df.spatial.full_extent))\n\n    elif data_type == \"gdf\":\n        if not all(df.geometry.type.isin([\"Polygon\", \"MultiPolygon\"])):\n            raise ValueError(\n                \"gdf must contain only Polygon or MultiPolygon geometries.\"\n            )\n        if df.crs is None:\n            df.set_crs(epsg=4326, inplace=True)\n        elif df.crs.to_epsg() != 4326:\n            df = df.to_crs(epsg=4326)\n        bounds = df.total_bounds  # returns (minx, miny, maxx, maxy)\n        return f\"{bounds[0]},{bounds[1]},{bounds[2]},{bounds[3]},EPSG:4326\"\n</code></pre>"},{"location":"reference/#kapipy.features.conversion.sdf_or_gdf_to_single_polygon_geojson","title":"<code>sdf_or_gdf_to_single_polygon_geojson(df)</code>","text":"<p>Convert a GeoDataFrame or SEDF to a single GeoJSON Polygon geometry object.</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>GeoDataFrame or GeoAccessor</code> <p>A GeoDataFrame or SEDF containing only Polygon geometries.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict[str, Any] | None</code> <p>A GeoJSON Polygon geometry object.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the DataFrame is empty or contains non-polygon geometries.</p> Source code in <code>src\\kapipy\\features\\conversion.py</code> <pre><code>def sdf_or_gdf_to_single_polygon_geojson(\n    df: Union[\"gpd.GeoDataFrame\", \"pd.DataFrame\"],\n) -&gt; dict[str, Any] | None:\n    \"\"\"\n    Convert a GeoDataFrame or SEDF to a single GeoJSON Polygon geometry object.\n\n    Parameters:\n        df (gpd.GeoDataFrame or arcgis.features.GeoAccessor): A GeoDataFrame or SEDF containing only Polygon geometries.\n\n    Returns:\n        dict: A GeoJSON Polygon geometry object.\n\n    Raises:\n        ValueError: If the DataFrame is empty or contains non-polygon geometries.\n    \"\"\"\n\n    if df.empty:\n        raise ValueError(\"sdf or gdf must contain at least one geometry.\")\n\n    data_type = get_data_type(df)\n    if data_type == \"sdf\":\n        if not df.spatial.geometry_type in [\"polygon\", \"multipolygon\"]:\n            raise ValueError(\"sdf must contain polygon geometries.\")\n        if df.spatial.sr.wkid == 4326:\n            df.spatial.project({\"wkid\": 4326})\n        geometries = sdf.spatial.geometry\n        shapes = [shape(geom) for geom in geometries]\n        unioned = unary_union(shapes)\n        # Convert the Shapely geometry to GeoJSON format\n        return mapping(unioned)\n\n    elif data_type == \"gdf\":\n        if not all(df.geometry.type == \"Polygon\"):\n            raise ValueError(\"GeoDataFrame must contain only Polygon geometries.\")\n\n        # convert crs to EPSG:4326 if not already\n        if df.crs is None:\n            df.set_crs(epsg=4326, inplace=True)\n        elif df.crs.to_epsg() != 4326:\n            df = df.to_crs(epsg=4326)\n\n        # Union all geometries into a single geometry\n        single_geometry = df.unary_union\n        if single_geometry.is_empty:\n            raise ValueError(\"Resulting geometry is empty after union.\")\n\n        return single_geometry.__geo_interface__\n</code></pre>"},{"location":"reference/#kapipy.features.wfs.download_wfs_data","title":"<code>download_wfs_data(url, typeNames, api_key, srsName=DEFAULT_SRSNAME, cql_filter=None, count=None, page_count=DEFAULT_PAGE_COUNT, **other_wfs_params)</code>","text":"<p>Downloads features from a WFS service, handling pagination and retries.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The base URL of the WFS service (e.g., \"https://data.linz.govt.nz/services/wfs\").</p> required <code>typeNames</code> <code>str</code> <p>The typeNames for the desired layer (e.g., \"layer-12345\").</p> required <code>api_key</code> <code>str</code> <p>API key.</p> required <code>srsName</code> <code>str</code> <p>Spatial Reference System name (e.g., \"EPSG:2193\"). Defaults to \"EPSG:2193\".</p> <code>DEFAULT_SRSNAME</code> <code>cql_filter</code> <code>str</code> <p>CQL filter to apply to the WFS request. Defaults to None.</p> <code>None</code> <code>count</code> <code>int</code> <p>Maximum number of features to fetch.</p> <code>None</code> <code>page_count</code> <code>int</code> <p>Number of features per page request. Defaults to DEFAULT_PAGE_COUNT.</p> <code>DEFAULT_PAGE_COUNT</code> <code>**other_wfs_params</code> <code>Any</code> <p>Additional WFS parameters.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A GeoJSON FeatureCollection-like dictionary containing all fetched features.</p> <p>Raises:</p> Type Description <code>HTTPError</code> <p>If the API key or typeNames is missing, or if data fetching fails after all retries.</p> <code>BadRequest</code> <p>If a 400 Bad Request is returned from the WFS service.</p> Source code in <code>src\\kapipy\\features\\wfs.py</code> <pre><code>def download_wfs_data(\n    url: str,\n    typeNames: str,\n    api_key: str,\n    srsName: str = DEFAULT_SRSNAME,\n    cql_filter: str = None,\n    count=None,\n    page_count: int = DEFAULT_PAGE_COUNT,\n    **other_wfs_params: Any,\n) -&gt; dict:\n    \"\"\"\n    Downloads features from a WFS service, handling pagination and retries.\n\n    Parameters:\n        url (str): The base URL of the WFS service (e.g., \"https://data.linz.govt.nz/services/wfs\").\n        typeNames (str): The typeNames for the desired layer (e.g., \"layer-12345\").\n        api_key (str): API key.\n        srsName (str, optional): Spatial Reference System name (e.g., \"EPSG:2193\"). Defaults to \"EPSG:2193\".\n        cql_filter (str, optional): CQL filter to apply to the WFS request. Defaults to None.\n        count (int, optional): Maximum number of features to fetch.\n        page_count (int, optional): Number of features per page request. Defaults to DEFAULT_PAGE_COUNT.\n        **other_wfs_params: Additional WFS parameters.\n\n    Returns:\n        dict: A GeoJSON FeatureCollection-like dictionary containing all fetched features.\n\n    Raises:\n        HTTPError: If the API key or typeNames is missing, or if data fetching fails after all retries.\n        BadRequest: If a 400 Bad Request is returned from the WFS service.\n    \"\"\"\n\n    if not api_key:\n        raise HTTPError(\"API key must be provided.\")\n    if not typeNames:\n        raise HTTPError(\"Typenames (i.e. layer id) must be provided.\")\n\n    headers = {\"Authorization\": f\"key {api_key}\"}\n    all_features = []\n    start_index = 0\n    page_count = min(page_count, count) if count is not None else page_count\n    crs_info = None\n    total_features_service_reported = None\n\n    # The final result to return\n    result = None\n\n    logger.debug(f\"Starting WFS data download for typeNames: '{typeNames}'\")\n    if cql_filter:\n        logger.debug(f\"Using CQL filter: {cql_filter}\")\n\n    pages_fetched = 0  # Track number of pages fetched to prevent infinite loops\n    while pages_fetched &lt; MAX_PAGE_FETCHES:\n        logger.debug(f\"Pages fetched: {pages_fetched} of max: {MAX_PAGE_FETCHES}\")\n        pages_fetched += 1\n        wfs_request_params = {\n            \"service\": DEFAULT_WFS_SERVICE,\n            \"version\": DEFAULT_WFS_VERSION,\n            \"request\": DEFAULT_WFS_REQUEST,\n            \"outputFormat\": DEFAULT_WFS_OUTPUT_FORMAT,\n            \"typeNames\": typeNames,\n            \"srsName\": srsName,\n            \"startIndex\": start_index,\n            \"count\": page_count,\n            \"cql_filter\": cql_filter,\n            **{k: v for k, v in other_wfs_params.items()},\n        }\n\n        try:\n            page_data = _fetch_single_page_data(url, headers, wfs_request_params)\n        except BadRequest as e:\n            logger.error(f\"### Bad request error: {e}\")\n            raise\n        except (\n            RetryError\n        ) as e:  # This occurs if tenacity gives up after all retry attempts\n            # The original exception from the last attempt is available in e.last_attempt.exception()\n            last_exception = e.last_attempt.exception() if e.last_attempt else e\n            logger.error(\n                f\"All retries failed for '{typeNames}' at startIndex {start_index}. Last error: {last_exception}\"\n            )\n            raise HTTPError(\n                f\"Failed to download WFS data for '{typeNames}' after multiple retries. Last error: {last_exception}\"\n            ) from last_exception\n        except (\n            HTTPError\n        ):  # Raised directly by _fetch_single_page_data for non-retryable issues\n            raise  # Propagate the error\n        except Exception as e:\n            logger.error(\n                f\"Unexpected error for '{typeNames}' at startIndex {start_index}: {e}\"\n            )\n            raise HTTPError(\n                f\"Failed to download WFS data for '{typeNames}' due to unexpected error: {e}\"\n            ) from e\n\n        if not page_data or not isinstance(page_data, dict):\n            logger.warning(\n                f\"Received empty or invalid data for '{typeNames}' at startIndex {start_index}. Assuming end of data.\"\n            )\n            break  # Stop if no data or unexpected format\n\n        result = page_data if result is None else result\n        features_on_page = page_data.get(\"features\", [])\n        if not features_on_page:\n            logger.debug(\n                f\"No more features found for '{typeNames}' at startIndex {start_index}. Download likely complete.\"\n            )\n            break  # No features on this page, assume end of data\n        all_features.extend(features_on_page)\n        logger.debug(\n            f\"Fetched {len(features_on_page)} features for '{typeNames}'. Total fetched so far: {len(all_features)}.\"\n        )\n        # Stop if this page had fewer features than requested (indicates last page)\n        if len(features_on_page) &lt; page_count:\n            logger.debug(\n                f\"Last page fetched for '{typeNames}' (received {len(features_on_page)} features, requested up to {page_count}).\"\n            )\n            break\n        # Stop if max count is set and reached\n        if count is not None and len(all_features) &gt;= count:\n            logger.debug(\n                f\"Reached maximum count of {count} features for '{typeNames}'. Stopping download.\"\n            )\n            break\n\n        start_index += page_count\n\n    result[\"features\"] = all_features\n\n    # The API seems to always return totalFeatures as \"unknown\" in the response\n    # So here we manually set it to the number of features retrieved.\n    result[\"totalFeatures\"] = len(all_features)\n    # Remove numberReturned because it relates to the last page, not the total\n    result.pop(\"numberReturned\", None)\n\n    logger.debug(\n        f\"Finished WFS data download for '{typeNames}'. Total features retrieved: {len(all_features)}.\"\n    )\n    return result\n</code></pre>"},{"location":"reference/#kapipy.features.export.request_export","title":"<code>request_export(api_url, api_key, id, data_type, kind, export_format, crs=None, extent=None, **kwargs)</code>","text":"<p>Requests an export of a given item from the Koordinates API.</p> <p>Parameters:</p> Name Type Description Default <code>api_url</code> <code>str</code> <p>The base URL of the Koordinates API.</p> required <code>api_key</code> <code>str</code> <p>The API key for authentication.</p> required <code>id</code> <code>str</code> <p>The ID of the item to export.</p> required <code>data_type</code> <code>str</code> <p>The type of data ('layer' or 'table').</p> required <code>kind</code> <code>str</code> <p>The kind of export (e.g., 'shp', 'geojson').</p> required <code>export_format</code> <code>str</code> <p>The format for the export.</p> required <code>crs</code> <code>str</code> <p>Coordinate Reference System, if applicable.</p> <code>None</code> <code>extent</code> <code>dict</code> <p>Spatial extent for the export.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters for the export.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The response from the export request, typically containing job details.</p> <p>Raises:</p> Type Description <code>ExportError</code> <p>If the export request fails or if the response cannot be parsed.</p> <code>ValueError</code> <p>If the data type is unsupported or not implemented.</p> Source code in <code>src\\kapipy\\features\\export.py</code> <pre><code>def request_export(\n    api_url: str,\n    api_key: str,\n    id: str,\n    data_type: str,\n    kind: str,\n    export_format: str,\n    crs: str = None,\n    extent: dict = None,\n    **kwargs: Any,\n) -&gt; dict:\n    \"\"\"\n    Requests an export of a given item from the Koordinates API.\n\n    Parameters:\n        api_url (str): The base URL of the Koordinates API.\n        api_key (str): The API key for authentication.\n        id (str): The ID of the item to export.\n        data_type (str): The type of data ('layer' or 'table').\n        kind (str): The kind of export (e.g., 'shp', 'geojson').\n        export_format (str): The format for the export.\n        crs (str, optional): Coordinate Reference System, if applicable.\n        extent (dict, optional): Spatial extent for the export.\n        **kwargs: Additional parameters for the export.\n\n    Returns:\n        dict: The response from the export request, typically containing job details.\n\n    Raises:\n        ExportError: If the export request fails or if the response cannot be parsed.\n        ValueError: If the data type is unsupported or not implemented.\n    \"\"\"\n\n    logger.debug(\"Requesting export\")\n\n    api_url = api_url if api_url.endswith(\"/\") else f\"{api_url}/\"\n    export_url = f\"{api_url}exports/\"\n    if data_type == \"layer\":\n        download_url = f\"{api_url}layers/\"\n    elif data_type == \"table\":\n        download_url = f\"{api_url}tables/\"\n    else:\n        raise ValueError(f\"Unsupported or not implemented data type: {data_type}\")\n    logger.debug(f\"{download_url=}\")\n\n    data = {\n        \"items\": [{\"item\": f\"{download_url}{id}/\"}],\n        \"formats\": {f\"{kind}\": export_format},\n        **kwargs,\n    }\n\n    if data_type == \"layer\" and crs:\n        data[\"crs\"] = crs\n    if data_type == \"layer\" and extent:\n        data[\"extent\"] = extent\n\n    logger.debug(f\"{data=}\")\n\n    headers = {\"Authorization\": f\"key {api_key}\"}\n\n    request_datetime = datetime.utcnow().isoformat()\n    try:\n        response = requests.post(export_url, headers=headers, json=data)\n        response.raise_for_status()\n        try:\n            json_response = response.json()\n        except ValueError as e:\n            err = f\"Error parsing JSON from export request: {e}\"\n            logger.debug(err)\n            raise ExportError(err)\n    except requests.exceptions.HTTPError as e:\n        err = f\"Failed export request with status code: {response.status_code}\"\n        logger.debug(err)\n        logger.debug(e)\n        raise ExportError(err)\n    return json_response\n</code></pre>"},{"location":"reference/#kapipy.features.export.validate_export_params","title":"<code>validate_export_params(api_url, api_key, id, data_type, kind, export_format, crs=None, extent=None, **kwargs)</code>","text":"<p>Validates export parameters for a given item.</p> <p>Parameters:</p> Name Type Description Default <code>api_url</code> <code>str</code> <p>The base URL of the Koordinates API.</p> required <code>api_key</code> <code>str</code> <p>The API key for authentication.</p> required <code>id</code> <code>str</code> <p>The ID of the item to export.</p> required <code>data_type</code> <code>str</code> <p>The type of data ('layer' or 'table').</p> required <code>kind</code> <code>str</code> <p>The kind of export (e.g., 'shp', 'geojson').</p> required <code>export_format</code> <code>str</code> <p>The format for the export.</p> required <code>crs</code> <code>str</code> <p>Coordinate Reference System, if applicable.</p> <code>None</code> <code>extent</code> <code>dict</code> <p>Spatial extent for the export.</p> <code>None</code> <code>**kwargs</code> <code>Any</code> <p>Additional parameters for the export.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the export parameters are valid, False otherwise.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the data type is unsupported or not implemented, or if validation fails.</p> Source code in <code>src\\kapipy\\features\\export.py</code> <pre><code>def validate_export_params(\n    api_url: str,\n    api_key: str,\n    id: str,\n    data_type: str,\n    kind: str,\n    export_format: str,\n    crs: str = None,\n    extent: dict = None,\n    **kwargs: Any,\n) -&gt; bool:\n    \"\"\"\n    Validates export parameters for a given item.\n\n    Parameters:\n        api_url (str): The base URL of the Koordinates API.\n        api_key (str): The API key for authentication.\n        id (str): The ID of the item to export.\n        data_type (str): The type of data ('layer' or 'table').\n        kind (str): The kind of export (e.g., 'shp', 'geojson').\n        export_format (str): The format for the export.\n        crs (str, optional): Coordinate Reference System, if applicable.\n        extent (dict, optional): Spatial extent for the export.\n        **kwargs: Additional parameters for the export.\n\n    Returns:\n        bool: True if the export parameters are valid, False otherwise.\n\n    Raises:\n        ValueError: If the data type is unsupported or not implemented, or if validation fails.\n    \"\"\"\n\n    logger.debug(\"Validating export parameters\")\n\n\n    api_url = api_url if api_url.endswith(\"/\") else f\"{api_url}/\"\n    if data_type == \"layer\":\n        download_url = f\"{api_url}layers/\"\n    elif data_type == \"table\":\n        download_url = f\"{api_url}tables/\"\n    else:\n        raise ValueError(f\"Unsupported or not implemented data type: {data_type}\")\n    validation_url = f\"{api_url}exports/validate/\"\n\n    logger.debug(f\"{download_url=}\")\n\n    data = {\n        \"items\": [{\"item\": f\"{download_url}{id}/\"}],\n        \"formats\": {f\"{kind}\": export_format},\n        **kwargs,\n    }\n\n    if data_type == \"layer\" and crs:\n        data[\"crs\"] = crs\n    if data_type == \"layer\" and extent:\n        data[\"extent\"] = extent\n\n    logger.debug(f\"{data=}\")\n\n    headers = {\"Authorization\": f\"key {api_key}\"}\n    is_valid = False\n\n    try:\n        response = requests.post(validation_url, headers=headers, json=data)\n        response.raise_for_status()\n\n        # if response has any 200 status code, check for validation errors\n        if response.status_code in (200, 201, \"200\", \"201\"):\n            try:\n                json_response = response.json()\n                if any(\n                    not item.get(\"is_valid\", \"true\") for item in json_response[\"items\"]\n                ):\n                    err = \"An error occured when attempting to validate an export with this configuration. Check for 'invalid_reasons' in the logs.\"\n                    logger.error(err)\n                    logger.error(json_response[\"items\"])\n                    raise ValueError(err)\n                is_valid = True\n            except ValueError as e:\n                err = f\"Error parsing JSON from export validation: {e}\"\n                logger.debug(err)\n                raise ValueError(err)\n\n    except requests.exceptions.HTTPError as e:\n        status = e.response.status_code if e.response is not None else None\n        logger.error(\n            f\"HTTP error during validation: {status} - {getattr(e.response, 'text', '')}\"\n        )\n        if 400 &lt;= status &lt; 500:\n            raise ValueError(\n                f\"Bad request ({status}) for URL {validation_url}: {getattr(e.response, 'text', '')}\"\n            ) from e\n        raise\n\n    logger.debug(f\"Export parameters passed validation check. {is_valid=}\")\n    return is_valid\n</code></pre>"},{"location":"reference/#kapipy.custom_errors.BadRequest","title":"<code>BadRequest</code>","text":"<p>               Bases: <code>HTTPError</code></p> <p>Exception raised for HTTP 400 Bad Request errors.</p> Source code in <code>src\\kapipy\\custom_errors.py</code> <pre><code>class BadRequest(HTTPError):\n    \"\"\"Exception raised for HTTP 400 Bad Request errors.\"\"\"\n</code></pre>"},{"location":"reference/#kapipy.custom_errors.ExportError","title":"<code>ExportError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Custom exception for errors encountered during export operations.</p> Source code in <code>src\\kapipy\\custom_errors.py</code> <pre><code>class ExportError(Exception):\n    \"\"\"Custom exception for errors encountered during export operations.\"\"\"\n</code></pre>"},{"location":"reference/#kapipy.custom_errors.HTTPError","title":"<code>HTTPError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for HTTP errors.</p> Source code in <code>src\\kapipy\\custom_errors.py</code> <pre><code>class HTTPError(Exception):\n    \"\"\"Base exception for HTTP errors.\"\"\"\n</code></pre>"},{"location":"reference/#kapipy.custom_errors.NotFound","title":"<code>NotFound</code>","text":"<p>               Bases: <code>HTTPError</code></p> <p>Exception raised for HTTP 404 Not Found errors.</p> Source code in <code>src\\kapipy\\custom_errors.py</code> <pre><code>class NotFound(HTTPError):\n    \"\"\"Exception raised for HTTP 404 Not Found errors.\"\"\"\n</code></pre>"},{"location":"reference/#kapipy.custom_errors.ServerError","title":"<code>ServerError</code>","text":"<p>               Bases: <code>HTTPError</code></p> <p>Exception raised for HTTP 500 Server Error errors.</p> Source code in <code>src\\kapipy\\custom_errors.py</code> <pre><code>class ServerError(HTTPError):\n    \"\"\"Exception raised for HTTP 500 Server Error errors.\"\"\"\n</code></pre>"},{"location":"reference/#kapipy.custom_errors.Unauthorized","title":"<code>Unauthorized</code>","text":"<p>               Bases: <code>HTTPError</code></p> <p>Exception raised for HTTP 401 Unauthorized errors.</p> Source code in <code>src\\kapipy\\custom_errors.py</code> <pre><code>class Unauthorized(HTTPError):\n    \"\"\"Exception raised for HTTP 401 Unauthorized errors.\"\"\"\n</code></pre>"},{"location":"reference/#kapipy.custom_errors.UnknownItemTypeError","title":"<code>UnknownItemTypeError</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when an unknown item type is encountered.</p> <p>This exception is used to signal that an item kind is not supported by the client.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Description of the error.</p> required <p>Attributes:</p> Name Type Description <code>message</code> <code>str</code> <p>Description of the error.</p> Source code in <code>src\\kapipy\\custom_errors.py</code> <pre><code>class UnknownItemTypeError(Exception):\n    \"\"\"\n    Exception raised when an unknown item type is encountered.\n\n    This exception is used to signal that an item kind is not supported by the client.\n\n    Parameters:\n        message (str): Description of the error.\n\n    Attributes:\n        message (str): Description of the error.\n    \"\"\"\n    def __init__(self, message: str):\n        \"\"\"\n        Initializes the UnknownItemTypeError with a descriptive error message.\n\n        Parameters:\n            message (str): Description of the error.\n        \"\"\"\n        super().__init__(message)\n        self.message = message\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Returns a user-friendly string representation of the error.\n\n        Returns:\n            str: The error message.\n        \"\"\"\n        return self.message\n</code></pre>"},{"location":"reference/#kapipy.custom_errors.UnknownItemTypeError.__init__","title":"<code>__init__(message)</code>","text":"<p>Initializes the UnknownItemTypeError with a descriptive error message.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Description of the error.</p> required Source code in <code>src\\kapipy\\custom_errors.py</code> <pre><code>def __init__(self, message: str):\n    \"\"\"\n    Initializes the UnknownItemTypeError with a descriptive error message.\n\n    Parameters:\n        message (str): Description of the error.\n    \"\"\"\n    super().__init__(message)\n    self.message = message\n</code></pre>"},{"location":"reference/#kapipy.custom_errors.UnknownItemTypeError.__str__","title":"<code>__str__()</code>","text":"<p>Returns a user-friendly string representation of the error.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The error message.</p> Source code in <code>src\\kapipy\\custom_errors.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Returns a user-friendly string representation of the error.\n\n    Returns:\n        str: The error message.\n    \"\"\"\n    return self.message\n</code></pre>"},{"location":"usage/","title":"Usage Guide","text":"<p>This guide walks you through the main ways to use the <code>kapipy</code> package to query and download data from the LINZ Data Service via Koordinates.</p>"},{"location":"usage/#installation-notes","title":"Installation Notes","text":"<p>Kapipy is designed to use either GeoPandas or the ArcGIS API for Python, returning and reading data as either a GeoDataFrame or a Spatially Enabled DataFrame respectively.  Neither package is defined as a requirement of kapipy, as users may choose to use one over the other and may not want the other automatically installed.  </p> <p>This means you need to manually instally one of either geopandas or arcgis into your Python environment.</p>"},{"location":"usage/#arcgis","title":"ArcGIS","text":"<p>If you are an ArcGIS user, cloning the default conda environment from ArcGIS Pro or ArcGIS Server should be sufficient, and you just need to install kapipy. If you choose to start with a blank environment and do not intend to install arcpy, you may need to install the following: - pyproj - shapely - pyshp  </p>"},{"location":"usage/#jupyter-notebooks","title":"Jupyter Notebooks","text":"<p>If you are starting with a clean Python environment and want to use Jupyter Notebooks (e.g. inside Visual Studio Code), then manually install these packages: - ipykernel - ptyprocess - comm  </p>"},{"location":"usage/#connecting-to-the-various-open-data-portals","title":"Connecting to the various open data portals","text":"<pre><code>from kapipy.gis import GIS\n\nlinz = GIS(name=\"linz\", api_key=\"your-linz-api-key\")\nstatsnz = GIS(name='statsnz', api_key=\"your-stats-api-key\")\nlris = GIS(name='lris', api_key=\"your-lris-api-key\")\n</code></pre>"},{"location":"usage/#get-a-reference-to-an-item","title":"Get a reference to an item","text":"<pre><code>from kapipy.gis import GIS\n\n#create gis object\nlinz = GIS(name=\"linz\", api_key=\"your-linz-api-key\")\n\n#get item object\nrail_station_layer_id = \"50318\" #rail station 175 points\nitm = linz.content.get(rail_station_layer_id)\n\nprint(itm)\n</code></pre>"},{"location":"usage/#query-an-item-using-wfs-endpoint","title":"Query an item using WFS endpoint","text":"<p>Get all data  </p> <pre><code>data = itm.query()\n</code></pre> <p>Get first 5 records.  </p> <pre><code>data = itm.query(count=5)\n</code></pre> <p>Data is returned as either a geopandas GeoDataFrame or an ArcGIS Spatially Enabled DataFrame, typed by the fields provided by the API.  </p> <pre><code>print(data.dtypes())\nprint(data.head())\n</code></pre>"},{"location":"usage/#get-a-changeset-using-wfs-endpoint","title":"Get a changeset using WFS endpoint","text":"<p>Also returned as a DataFrame.</p> <pre><code>changeset = itm.get_changeset(from_time=\"2024-01-01T00:00:00Z\", wkid=2193)\nprint((f\"Total records returned {itm.title}: {changeset.shape[0]}\"))\n</code></pre>"},{"location":"usage/#generate-an-export","title":"Generate an export","text":"<p>It is recommended to always specify the wkid.  </p> <pre><code>job = itm.export(\"geodatabase\", wkid=2193)\nprint(job.status)\n</code></pre> <p>Download the job data once it is ready. If this method is called before the job is complete, it will keep polling the status of the job until it is ready and then downloads it.  </p> <pre><code>job.download(folder=r\"c:/temp\")\n</code></pre>"},{"location":"usage/#generate-an-export-with-extent-geometry","title":"Generate an export with extent geometry","text":"<p>The extent argument can be passed in as a GeoDataFrame or a Spatially Enabled DataFrame.  </p> <pre><code>waikato_polygon = gpd.read_file('../examples/waikato.json')\nmatamata_gdf = gpd.read_file(\"../examples/matamata_piako.shp\")\n\njob = itm.export(\"geodatabase\", wkid=2193, extent=waikato_polygon,)\nprint(job.status)\n</code></pre>"}]}